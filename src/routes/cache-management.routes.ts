/**\n * Cache Management Routes\n * API endpoints for monitoring, testing, and managing the advanced cache system\n */\n\nimport { getAdvancedCacheManager } from '../cache/advanced-cache-manager';\nimport { getIntelligentCacheWarmer } from '../cache/intelligent-cache-warmer';\nimport { getCacheOptimizer } from '../cache/cache-performance-optimizer';\n\nexport async function handleCacheRoutes(request: Request, env: any): Promise<Response> {\n  const url = new URL(request.url);\n  const path = url.pathname;\n  const method = request.method;\n  \n  const cacheManager = getAdvancedCacheManager();\n  const warmer = getIntelligentCacheWarmer();\n  const optimizer = getCacheOptimizer();\n  \n  if (!cacheManager || !warmer || !optimizer) {\n    return new Response(JSON.stringify({\n      success: false,\n      error: 'Cache system not initialized'\n    }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n  \n  try {\n    // GET /api/cache/health - Get cache health status\n    if (path === '/api/cache/health' && method === 'GET') {\n      const healthStatus = await cacheManager.getHealthStatus();\n      \n      return new Response(JSON.stringify({\n        success: true,\n        data: healthStatus,\n        timestamp: new Date().toISOString()\n      }), {\n        status: healthStatus.healthy ? 200 : 503,\n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n    }\n    \n    // GET /api/cache/metrics - Get detailed cache metrics\n    if (path === '/api/cache/metrics' && method === 'GET') {\n      const analytics = cacheManager.getAnalytics();\n      \n      return new Response(JSON.stringify({\n        success: true,\n        data: analytics,\n        timestamp: new Date().toISOString()\n      }), {\n        status: 200,\n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n    }\n    \n    // GET /api/cache/insights - Get optimization insights\n    if (path === '/api/cache/insights' && method === 'GET') {\n      const insights = optimizer.getOptimizationInsights();\n      \n      return new Response(JSON.stringify({\n        success: true,\n        data: insights,\n        timestamp: new Date().toISOString()\n      }), {\n        status: 200,\n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n    }\n    \n    // POST /api/cache/warm - Trigger cache warming\n    if (path === '/api/cache/warm' && method === 'POST') {\n      console.log('Manual cache warming triggered');\n      const result = await cacheManager.warmCache();\n      \n      return new Response(JSON.stringify({\n        success: true,\n        message: 'Cache warming completed',\n        data: result,\n        timestamp: new Date().toISOString()\n      }), {\n        status: 200,\n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n    }\n    \n    // POST /api/cache/optimize - Trigger cache optimization\n    if (path === '/api/cache/optimize' && method === 'POST') {\n      console.log('Manual cache optimization triggered');\n      const result = await cacheManager.optimize();\n      \n      return new Response(JSON.stringify({\n        success: true,\n        message: 'Cache optimization completed',\n        data: result,\n        timestamp: new Date().toISOString()\n      }), {\n        status: 200,\n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n    }\n    \n    // POST /api/cache/invalidate - Invalidate cache\n    if (path === '/api/cache/invalidate' && method === 'POST') {\n      const body = await request.json() as {\n        pattern?: string;\n        tags?: string[];\n        endpoints?: string[];\n        clearFallback?: boolean;\n      };\n      \n      console.log('Cache invalidation triggered:', body);\n      const result = await cacheManager.invalidate(body.pattern, {\n        tags: body.tags,\n        endpoints: body.endpoints,\n        clearFallback: body.clearFallback\n      });\n      \n      return new Response(JSON.stringify({\n        success: true,\n        message: 'Cache invalidation completed',\n        data: result,\n        timestamp: new Date().toISOString()\n      }), {\n        status: 200,\n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n    }\n    \n    // GET /api/cache/test/{endpoint} - Test cache performance for specific endpoint\n    if (path.startsWith('/api/cache/test/') && method === 'GET') {\n      const testEndpoint = path.substring('/api/cache/test/'.length);\n      const iterations = parseInt(url.searchParams.get('iterations') || '10');\n      const clearCache = url.searchParams.get('clear') === 'true';\n      \n      if (clearCache) {\n        await cacheManager.invalidate(testEndpoint);\n      }\n      \n      const results = {\n        endpoint: testEndpoint,\n        iterations,\n        clearedCache: clearCache,\n        tests: [] as any[],\n        summary: {\n          totalRequests: 0,\n          cacheHits: 0,\n          cacheMisses: 0,\n          averageLatency: 0,\n          hitRate: 0\n        }\n      };\n      \n      let totalLatency = 0;\n      \n      // Perform test iterations\n      for (let i = 0; i < iterations; i++) {\n        const startTime = Date.now();\n        \n        try {\n          const result = await cacheManager.get(testEndpoint, {\n            test: 'true',\n            iteration: i.toString()\n          });\n          \n          const latency = Date.now() - startTime;\n          totalLatency += latency;\n          \n          const testResult = {\n            iteration: i + 1,\n            success: result.success,\n            source: result.source,\n            latency,\n            cacheKey: result.cacheKey\n          };\n          \n          results.tests.push(testResult);\n          results.summary.totalRequests++;\n          \n          if (result.source === 'cache') {\n            results.summary.cacheHits++;\n          } else {\n            results.summary.cacheMisses++;\n          }\n          \n          // Small delay between iterations\n          if (i < iterations - 1) {\n            await new Promise(resolve => setTimeout(resolve, 50));\n          }\n          \n        } catch (error) {\n          results.tests.push({\n            iteration: i + 1,\n            success: false,\n            error: error instanceof Error ? error.message : String(error),\n            latency: Date.now() - startTime\n          });\n        }\n      }\n      \n      // Calculate summary statistics\n      results.summary.averageLatency = totalLatency / results.summary.totalRequests;\n      results.summary.hitRate = (results.summary.cacheHits / results.summary.totalRequests) * 100;\n      \n      return new Response(JSON.stringify({\n        success: true,\n        data: results,\n        timestamp: new Date().toISOString()\n      }), {\n        status: 200,\n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n    }\n    \n    // POST /api/cache/benchmark - Run comprehensive cache benchmark\n    if (path === '/api/cache/benchmark' && method === 'POST') {\n      const body = await request.json() as {\n        endpoints?: string[];\n        iterations?: number;\n        warmCache?: boolean;\n        testDuration?: number;\n      };\n      \n      const testEndpoints = body.endpoints || [\n        'pitches/browse/enhanced',\n        'pitches/trending',\n        'pitches/new',\n        'dashboard/stats',\n        'config/app'\n      ];\n      \n      const iterations = body.iterations || 20;\n      const warmCache = body.warmCache !== false;\n      const testDuration = body.testDuration || 60000; // 1 minute\n      \n      console.log(`Starting cache benchmark: ${testEndpoints.length} endpoints, ${iterations} iterations`);\n      \n      // Warm cache if requested\n      if (warmCache) {\n        await cacheManager.warmCache();\n        // Allow warming to settle\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n      \n      const benchmarkResults = {\n        config: {\n          endpoints: testEndpoints,\n          iterations,\n          warmCache,\n          testDuration\n        },\n        results: [] as any[],\n        summary: {\n          totalRequests: 0,\n          totalCacheHits: 0,\n          totalCacheMisses: 0,\n          averageLatency: 0,\n          overallHitRate: 0,\n          testDurationActual: 0\n        }\n      };\n      \n      const startTime = Date.now();\n      let totalRequests = 0;\n      let totalHits = 0;\n      let totalLatency = 0;\n      \n      // Test each endpoint\n      for (const endpoint of testEndpoints) {\n        const endpointResults = {\n          endpoint,\n          requests: 0,\n          hits: 0,\n          misses: 0,\n          averageLatency: 0,\n          hitRate: 0,\n          errors: 0\n        };\n        \n        let endpointLatency = 0;\n        \n        // Run iterations for this endpoint\n        for (let i = 0; i < iterations; i++) {\n          const iterationStart = Date.now();\n          \n          try {\n            const result = await cacheManager.get(endpoint, {\n              benchmark: 'true',\n              iteration: i.toString(),\n              timestamp: Date.now().toString()\n            });\n            \n            const latency = Date.now() - iterationStart;\n            endpointLatency += latency;\n            totalLatency += latency;\n            \n            endpointResults.requests++;\n            totalRequests++;\n            \n            if (result.source === 'cache') {\n              endpointResults.hits++;\n              totalHits++;\n            } else {\n              endpointResults.misses++;\n            }\n            \n          } catch (error) {\n            endpointResults.errors++;\n            console.error(`Benchmark error for ${endpoint}, iteration ${i}:`, error);\n          }\n          \n          // Check if we've exceeded test duration\n          if (Date.now() - startTime > testDuration) {\n            console.log(`Benchmark stopped early due to time limit (${testDuration}ms)`);\n            break;\n          }\n          \n          // Small delay between requests\n          await new Promise(resolve => setTimeout(resolve, 25));\n        }\n        \n        // Calculate endpoint statistics\n        endpointResults.averageLatency = endpointResults.requests > 0 \n          ? endpointLatency / endpointResults.requests \n          : 0;\n        endpointResults.hitRate = endpointResults.requests > 0 \n          ? (endpointResults.hits / endpointResults.requests) * 100 \n          : 0;\n        \n        benchmarkResults.results.push(endpointResults);\n        \n        if (Date.now() - startTime > testDuration) break;\n      }\n      \n      // Calculate overall statistics\n      benchmarkResults.summary.totalRequests = totalRequests;\n      benchmarkResults.summary.totalCacheHits = totalHits;\n      benchmarkResults.summary.totalCacheMisses = totalRequests - totalHits;\n      benchmarkResults.summary.averageLatency = totalRequests > 0 ? totalLatency / totalRequests : 0;\n      benchmarkResults.summary.overallHitRate = totalRequests > 0 ? (totalHits / totalRequests) * 100 : 0;\n      benchmarkResults.summary.testDurationActual = Date.now() - startTime;\n      \n      console.log(`Benchmark completed: ${totalRequests} requests, ${benchmarkResults.summary.overallHitRate.toFixed(1)}% hit rate`);\n      \n      return new Response(JSON.stringify({\n        success: true,\n        data: benchmarkResults,\n        timestamp: new Date().toISOString()\n      }), {\n        status: 200,\n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n    }\n    \n    // GET /api/cache/diagnostics - Get diagnostic information\n    if (path === '/api/cache/diagnostics' && method === 'GET') {\n      const diagnostics = optimizer.getDiagnostics();\n      const warmerMetrics = warmer.getMetrics();\n      const managerAnalytics = cacheManager.getAnalytics();\n      \n      return new Response(JSON.stringify({\n        success: true,\n        data: {\n          optimizer: diagnostics,\n          warmer: warmerMetrics,\n          manager: managerAnalytics,\n          system: {\n            timestamp: Date.now(),\n            uptime: Date.now() - (globalThis.workerStartTime || Date.now()),\n            memoryUsage: {\n              fallbackCacheEntries: managerAnalytics.fallbackStats.entries,\n              fallbackCacheSizeBytes: managerAnalytics.fallbackStats.totalSizeBytes\n            }\n          }\n        },\n        timestamp: new Date().toISOString()\n      }), {\n        status: 200,\n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n    }\n    \n    // POST /api/cache/reset - Reset cache statistics and data\n    if (path === '/api/cache/reset' && method === 'POST') {\n      const body = await request.json() as {\n        resetData?: boolean;\n        resetStats?: boolean;\n        resetFallback?: boolean;\n      };\n      \n      console.log('Cache reset triggered:', body);\n      \n      if (body.resetStats !== false) {\n        cacheManager.reset();\n      }\n      \n      if (body.resetData === true) {\n        await cacheManager.invalidate(undefined, {\n          clearFallback: body.resetFallback !== false\n        });\n      }\n      \n      return new Response(JSON.stringify({\n        success: true,\n        message: 'Cache reset completed',\n        resetActions: {\n          statistics: body.resetStats !== false,\n          cacheData: body.resetData === true,\n          fallbackCache: body.resetFallback !== false\n        },\n        timestamp: new Date().toISOString()\n      }), {\n        status: 200,\n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        }\n      });\n    }\n    \n    // Method not allowed or path not found\n    return new Response(JSON.stringify({\n      success: false,\n      error: 'Cache management endpoint not found',\n      availableEndpoints: [\n        'GET /api/cache/health',\n        'GET /api/cache/metrics',\n        'GET /api/cache/insights',\n        'GET /api/cache/diagnostics',\n        'GET /api/cache/test/{endpoint}',\n        'POST /api/cache/warm',\n        'POST /api/cache/optimize',\n        'POST /api/cache/invalidate',\n        'POST /api/cache/benchmark',\n        'POST /api/cache/reset'\n      ]\n    }), {\n      status: path.startsWith('/api/cache/') ? 404 : 405,\n      headers: { \n        'Content-Type': 'application/json',\n        'Cache-Control': 'no-cache'\n      }\n    });\n    \n  } catch (error) {\n    console.error('Cache management route error:', error);\n    \n    return new Response(JSON.stringify({\n      success: false,\n      error: 'Internal cache management error',\n      message: error instanceof Error ? error.message : String(error)\n    }), {\n      status: 500,\n      headers: { \n        'Content-Type': 'application/json',\n        'Cache-Control': 'no-cache'\n      }\n    });\n  }\n}"