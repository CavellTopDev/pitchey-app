#!/usr/bin/env python3
"""Comprehensive vulnerability scanning system for Pitchey Container Services.

This module provides automated security scanning including:
- Container image vulnerability scanning with Trivy
- Runtime security monitoring with custom rules
- Compliance checking against CIS benchmarks
- Security audit logging and SIEM integration
- Secret scanning and rotation
- Network policy validation
"""

import asyncio
import json
import logging
import os
import subprocess
import sys
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from enum import Enum
import yaml
import requests
import docker
from cryptography import x509
from cryptography.hazmat.backends import default_backend

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class SeverityLevel(Enum):
    """Vulnerability severity levels."""
    UNKNOWN = "UNKNOWN"
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"

class ComplianceStatus(Enum):
    """Compliance check status."""
    PASS = "PASS"
    FAIL = "FAIL"
    WARNING = "WARNING"
    NOT_APPLICABLE = "NOT_APPLICABLE"

@dataclass
class Vulnerability:
    """Vulnerability data structure."""
    id: str
    package_name: str
    installed_version: str
    fixed_version: Optional[str]
    severity: SeverityLevel
    title: str
    description: str
    references: List[str]
    cvss_score: Optional[float]
    published_date: Optional[datetime]
    last_modified_date: Optional[datetime]

@dataclass
class ComplianceCheck:
    """Compliance check result."""
    rule_id: str
    rule_name: str
    status: ComplianceStatus
    severity: SeverityLevel
    description: str
    remediation: str
    evidence: Optional[str]
    automated_fix: Optional[str]

@dataclass
class SecurityScanReport:
    """Complete security scan report."""
    scan_id: str
    timestamp: datetime
    target: str
    scan_type: str
    vulnerabilities: List[Vulnerability]
    compliance_checks: List[ComplianceCheck]
    summary: Dict[str, int]
    recommendations: List[str]
    scan_duration_seconds: float

class VulnerabilityScanner:
    """Comprehensive vulnerability scanner for containers."""
    
    def __init__(self, config_path: str = "/etc/security/scanner-config.yml"):
        self.config_path = config_path
        self.config = self._load_config()
        self.docker_client = docker.from_env()
        self.scan_results_dir = Path("/var/log/security/scans")
        self.scan_results_dir.mkdir(parents=True, exist_ok=True)
        
    def _load_config(self) -> Dict[str, Any]:
        """Load scanner configuration."""
        default_config = {
            "trivy": {
                "cache_dir": "/tmp/trivy-cache",
                "severity_levels": ["HIGH", "CRITICAL"],
                "ignore_unfixed": False,
                "timeout": "10m"
            },
            "compliance": {
                "frameworks": ["cis-docker", "owasp-asvs"],
                "custom_rules_dir": "/etc/security/rules"
            },
            "notifications": {
                "webhook_url": None,
                "slack_channel": "#security",
                "email_recipients": ["security-team@pitchey.com"]
            },
            "remediation": {
                "auto_patch": False,
                "create_tickets": True,
                "quarantine_critical": True
            }
        }
        
        if os.path.exists(self.config_path):
            with open(self.config_path, 'r') as f:
                loaded_config = yaml.safe_load(f)
                default_config.update(loaded_config)
                
        return default_config
        
    async def scan_container_image(self, image_name: str) -> SecurityScanReport:
        """Scan container image for vulnerabilities."""
        scan_start = time.time()
        scan_id = f"img_scan_{int(time.time())}_{image_name.replace(':', '_').replace('/', '_')}"
        
        logger.info(f"Starting vulnerability scan for image: {image_name}")
        
        vulnerabilities = []
        try:
            # Run Trivy scan
            trivy_results = await self._run_trivy_scan(image_name)
            vulnerabilities.extend(self._parse_trivy_results(trivy_results))
            
        except Exception as e:
            logger.error(f"Trivy scan failed for {image_name}: {e}")
            
        # Run compliance checks
        compliance_checks = await self._run_compliance_checks(image_name)
        
        scan_duration = time.time() - scan_start
        
        # Generate summary
        summary = self._generate_summary(vulnerabilities, compliance_checks)
        
        # Generate recommendations
        recommendations = self._generate_recommendations(vulnerabilities, compliance_checks)
        
        report = SecurityScanReport(
            scan_id=scan_id,
            timestamp=datetime.utcnow(),
            target=image_name,
            scan_type="container_image",
            vulnerabilities=vulnerabilities,
            compliance_checks=compliance_checks,
            summary=summary,
            recommendations=recommendations,
            scan_duration_seconds=scan_duration
        )
        
        # Save report
        await self._save_scan_report(report)
        
        # Send notifications if needed
        await self._process_notifications(report)
        
        logger.info(f"Completed scan for {image_name} in {scan_duration:.2f}s")
        return report
        
    async def _run_trivy_scan(self, image_name: str) -> Dict[str, Any]:
        """Run Trivy vulnerability scan."""
        cache_dir = self.config["trivy"]["cache_dir"]
        os.makedirs(cache_dir, exist_ok=True)
        
        cmd = [
            "trivy",
            "image",
            "--format", "json",
            "--cache-dir", cache_dir,
            "--timeout", self.config["trivy"]["timeout"],
            "--severity", ",".join(self.config["trivy"]["severity_levels"]),
            image_name
        ]
        
        if self.config["trivy"]["ignore_unfixed"]:
            cmd.append("--ignore-unfixed")
            
        logger.debug(f"Running Trivy command: {' '.join(cmd)}")
        
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await process.communicate()
        
        if process.returncode != 0:
            error_msg = stderr.decode() if stderr else "Unknown error"
            raise Exception(f"Trivy scan failed: {error_msg}")
            
        return json.loads(stdout.decode())
        
    def _parse_trivy_results(self, trivy_data: Dict[str, Any]) -> List[Vulnerability]:
        """Parse Trivy scan results into vulnerability objects."""
        vulnerabilities = []
        
        results = trivy_data.get("Results", [])
        for result in results:
            target = result.get("Target", "")
            vulns = result.get("Vulnerabilities", [])
            
            for vuln_data in vulns:
                vulnerability = Vulnerability(
                    id=vuln_data.get("VulnerabilityID", ""),
                    package_name=vuln_data.get("PkgName", ""),
                    installed_version=vuln_data.get("InstalledVersion", ""),
                    fixed_version=vuln_data.get("FixedVersion"),
                    severity=SeverityLevel(vuln_data.get("Severity", "UNKNOWN")),
                    title=vuln_data.get("Title", ""),
                    description=vuln_data.get("Description", ""),
                    references=vuln_data.get("References", []),
                    cvss_score=self._extract_cvss_score(vuln_data),
                    published_date=self._parse_date(vuln_data.get("PublishedDate")),
                    last_modified_date=self._parse_date(vuln_data.get("LastModifiedDate"))
                )
                vulnerabilities.append(vulnerability)
                
        return vulnerabilities
        
    def _extract_cvss_score(self, vuln_data: Dict[str, Any]) -> Optional[float]:
        """Extract CVSS score from vulnerability data."""
        cvss = vuln_data.get("CVSS", {})
        if isinstance(cvss, dict):
            for version, data in cvss.items():
                if isinstance(data, dict) and "V3Score" in data:
                    return data["V3Score"]
                elif isinstance(data, dict) and "V2Score" in data:
                    return data["V2Score"]
        return None
        
    def _parse_date(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parse date string to datetime object."""
        if not date_str:
            return None
        try:
            return datetime.fromisoformat(date_str.replace('Z', '+00:00'))
        except ValueError:
            return None
            
    async def _run_compliance_checks(self, image_name: str) -> List[ComplianceCheck]:
        """Run compliance checks against security frameworks."""
        compliance_checks = []
        
        # CIS Docker Benchmark checks
        cis_checks = await self._run_cis_docker_checks(image_name)
        compliance_checks.extend(cis_checks)
        
        # OWASP ASVS checks
        owasp_checks = await self._run_owasp_checks(image_name)
        compliance_checks.extend(owasp_checks)
        
        # Custom security rules
        custom_checks = await self._run_custom_security_checks(image_name)
        compliance_checks.extend(custom_checks)
        
        return compliance_checks
        
    async def _run_cis_docker_checks(self, image_name: str) -> List[ComplianceCheck]:
        """Run CIS Docker Benchmark compliance checks."""
        checks = []
        
        try:
            # Inspect image for CIS compliance
            image = self.docker_client.images.get(image_name)
            image_config = image.attrs.get("Config", {})
            
            # Check 4.1: Create a user for the container
            user = image_config.get("User")
            if not user or user == "root" or user == "0":
                checks.append(ComplianceCheck(
                    rule_id="CIS-4.1",
                    rule_name="Create a user for the container",
                    status=ComplianceStatus.FAIL,
                    severity=SeverityLevel.MEDIUM,
                    description="Container should not run as root user",
                    remediation="Add USER directive in Dockerfile to run as non-root user",
                    evidence=f"Container runs as user: {user or 'root'}",
                    automated_fix="USER nonroot"
                ))
            else:
                checks.append(ComplianceCheck(
                    rule_id="CIS-4.1",
                    rule_name="Create a user for the container",
                    status=ComplianceStatus.PASS,
                    severity=SeverityLevel.MEDIUM,
                    description="Container runs as non-root user",
                    remediation="N/A",
                    evidence=f"Container runs as user: {user}",
                    automated_fix=None
                ))
                
            # Check 4.7: Do not map privileged ports within containers
            exposed_ports = image_config.get("ExposedPorts", {})
            privileged_ports = [port for port in exposed_ports.keys() 
                              if int(port.split('/')[0]) < 1024]
            
            if privileged_ports:
                checks.append(ComplianceCheck(
                    rule_id="CIS-4.7",
                    rule_name="Do not map privileged ports within containers",
                    status=ComplianceStatus.WARNING,
                    severity=SeverityLevel.LOW,
                    description="Container exposes privileged ports (< 1024)",
                    remediation="Use non-privileged ports (>= 1024) and map to privileged ports via proxy",
                    evidence=f"Privileged ports exposed: {privileged_ports}",
                    automated_fix=None
                ))
            else:
                checks.append(ComplianceCheck(
                    rule_id="CIS-4.7",
                    rule_name="Do not map privileged ports within containers",
                    status=ComplianceStatus.PASS,
                    severity=SeverityLevel.LOW,
                    description="No privileged ports exposed",
                    remediation="N/A",
                    evidence="No privileged ports found",
                    automated_fix=None
                ))
                
        except Exception as e:
            logger.error(f"CIS Docker checks failed: {e}")
            
        return checks
        
    async def _run_owasp_checks(self, image_name: str) -> List[ComplianceCheck]:
        """Run OWASP Application Security Verification Standard checks."""
        checks = []
        
        try:
            image = self.docker_client.images.get(image_name)
            image_config = image.attrs.get("Config", {})
            
            # Check for environment variables with secrets
            env_vars = image_config.get("Env", [])
            secret_patterns = ["PASSWORD", "SECRET", "KEY", "TOKEN", "CREDENTIAL"]
            
            suspicious_env_vars = []
            for env_var in env_vars:
                for pattern in secret_patterns:
                    if pattern in env_var.upper() and "=" in env_var:
                        suspicious_env_vars.append(env_var.split("=")[0])
                        
            if suspicious_env_vars:
                checks.append(ComplianceCheck(
                    rule_id="OWASP-V14.2.1",
                    rule_name="Sensitive data not hardcoded in environment",
                    status=ComplianceStatus.FAIL,
                    severity=SeverityLevel.HIGH,
                    description="Potential secrets found in environment variables",
                    remediation="Use secret management system instead of environment variables",
                    evidence=f"Suspicious environment variables: {suspicious_env_vars}",
                    automated_fix=None
                ))
                
            # Check for HTTPS/TLS configuration
            labels = image.attrs.get("Config", {}).get("Labels", {}) or {}
            if "https" not in str(labels).lower() and "tls" not in str(labels).lower():
                checks.append(ComplianceCheck(
                    rule_id="OWASP-V9.1.1",
                    rule_name="TLS encryption for all client connectivity",
                    status=ComplianceStatus.WARNING,
                    severity=SeverityLevel.MEDIUM,
                    description="No explicit HTTPS/TLS configuration found",
                    remediation="Ensure all client communication uses TLS encryption",
                    evidence="No TLS-related labels or configuration found",
                    automated_fix=None
                ))
                
        except Exception as e:
            logger.error(f"OWASP checks failed: {e}")
            
        return checks
        
    async def _run_custom_security_checks(self, image_name: str) -> List[ComplianceCheck]:
        """Run custom security checks specific to Pitchey."""
        checks = []
        
        try:
            # Check for required security labels
            image = self.docker_client.images.get(image_name)
            labels = image.attrs.get("Config", {}).get("Labels", {}) or {}
            
            required_labels = [
                "security.scan.date",
                "security.approved.by",
                "version"
            ]
            
            missing_labels = [label for label in required_labels if label not in labels]
            
            if missing_labels:
                checks.append(ComplianceCheck(
                    rule_id="PITCHEY-SEC-001",
                    rule_name="Required security labels present",
                    status=ComplianceStatus.FAIL,
                    severity=SeverityLevel.MEDIUM,
                    description="Image missing required security labels",
                    remediation=f"Add missing labels: {', '.join(missing_labels)}",
                    evidence=f"Missing labels: {missing_labels}",
                    automated_fix=None
                ))
                
            # Check for package manager cache cleanup
            history = image.history()
            cache_cleanup_found = False
            
            for layer in history:
                created_by = layer.get("CreatedBy", "")
                if any(cmd in created_by.lower() for cmd in ["apt-get clean", "yum clean", "apk del", "rm -rf /var/cache"]):
                    cache_cleanup_found = True
                    break
                    
            if not cache_cleanup_found:
                checks.append(ComplianceCheck(
                    rule_id="PITCHEY-SEC-002",
                    rule_name="Package manager cache cleanup",
                    status=ComplianceStatus.WARNING,
                    severity=SeverityLevel.LOW,
                    description="Package manager cache not cleaned up",
                    remediation="Add cache cleanup commands to Dockerfile",
                    evidence="No cache cleanup commands found in image history",
                    automated_fix="RUN apt-get clean && rm -rf /var/lib/apt/lists/*"
                ))
                
        except Exception as e:
            logger.error(f"Custom security checks failed: {e}")
            
        return checks
        
    def _generate_summary(self, vulnerabilities: List[Vulnerability], 
                         compliance_checks: List[ComplianceCheck]) -> Dict[str, int]:
        """Generate summary statistics."""
        vuln_summary = {}
        for severity in SeverityLevel:
            vuln_summary[f"vulnerabilities_{severity.value.lower()}"] = sum(
                1 for v in vulnerabilities if v.severity == severity
            )
            
        compliance_summary = {}
        for status in ComplianceStatus:
            compliance_summary[f"compliance_{status.value.lower()}"] = sum(
                1 for c in compliance_checks if c.status == status
            )
            
        return {
            **vuln_summary,
            **compliance_summary,
            "total_vulnerabilities": len(vulnerabilities),
            "total_compliance_checks": len(compliance_checks)
        }
        
    def _generate_recommendations(self, vulnerabilities: List[Vulnerability],
                                compliance_checks: List[ComplianceCheck]) -> List[str]:
        """Generate actionable security recommendations."""
        recommendations = []
        
        # Critical vulnerability recommendations
        critical_vulns = [v for v in vulnerabilities if v.severity == SeverityLevel.CRITICAL]
        if critical_vulns:
            recommendations.append(
                f"URGENT: {len(critical_vulns)} critical vulnerabilities found. "
                "Update affected packages immediately."
            )
            
        # Compliance failure recommendations
        failed_checks = [c for c in compliance_checks if c.status == ComplianceStatus.FAIL]
        if failed_checks:
            recommendations.append(
                f"Security compliance: {len(failed_checks)} checks failed. "
                "Review and fix compliance violations."
            )
            
        # Specific recommendations based on findings
        if any("root" in v.package_name.lower() for v in vulnerabilities):
            recommendations.append(
                "Consider running containers as non-root user for better security isolation."
            )
            
        if not vulnerabilities and not failed_checks:
            recommendations.append(
                "No security issues found. Consider setting up automated scanning pipeline."
            )
            
        return recommendations
        
    async def _save_scan_report(self, report: SecurityScanReport) -> None:
        """Save scan report to file system."""
        report_file = self.scan_results_dir / f"{report.scan_id}.json"
        
        # Convert dataclasses to dict for JSON serialization
        report_dict = asdict(report)
        
        # Handle datetime serialization
        for vuln in report_dict["vulnerabilities"]:
            if vuln["published_date"]:
                vuln["published_date"] = vuln["published_date"].isoformat()
            if vuln["last_modified_date"]:
                vuln["last_modified_date"] = vuln["last_modified_date"].isoformat()
                
        report_dict["timestamp"] = report_dict["timestamp"].isoformat()
        
        with open(report_file, 'w') as f:
            json.dump(report_dict, f, indent=2, default=str)
            
        logger.info(f"Scan report saved: {report_file}")
        
    async def _process_notifications(self, report: SecurityScanReport) -> None:
        """Send notifications for security findings."""
        critical_vulns = [v for v in report.vulnerabilities 
                         if v.severity == SeverityLevel.CRITICAL]
        failed_checks = [c for c in report.compliance_checks 
                        if c.status == ComplianceStatus.FAIL]
        
        if critical_vulns or failed_checks:
            await self._send_security_alert(report, critical_vulns, failed_checks)
            
    async def _send_security_alert(self, report: SecurityScanReport,
                                  critical_vulns: List[Vulnerability],
                                  failed_checks: List[ComplianceCheck]) -> None:
        """Send security alert notification."""
        notification_config = self.config.get("notifications", {})
        
        alert_message = {
            "timestamp": report.timestamp.isoformat(),
            "target": report.target,
            "scan_id": report.scan_id,
            "critical_vulnerabilities": len(critical_vulns),
            "compliance_failures": len(failed_checks),
            "summary": report.summary,
            "recommendations": report.recommendations
        }
        
        # Send to webhook if configured
        webhook_url = notification_config.get("webhook_url")
        if webhook_url:
            try:
                response = requests.post(webhook_url, json=alert_message, timeout=30)
                response.raise_for_status()
                logger.info("Security alert sent to webhook")
            except Exception as e:
                logger.error(f"Failed to send webhook notification: {e}")
                
        logger.info(f"Security alert processed for {report.target}")

async def scan_all_containers():
    """Scan all running containers for vulnerabilities."""
    scanner = VulnerabilityScanner()
    
    try:
        client = docker.from_env()
        containers = client.containers.list()
        
        for container in containers:
            image_name = container.image.tags[0] if container.image.tags else container.image.id
            logger.info(f"Scanning container: {container.name} (image: {image_name})")
            
            try:
                report = await scanner.scan_container_image(image_name)
                logger.info(f"Scan completed for {container.name}: "
                          f"{report.summary['total_vulnerabilities']} vulnerabilities, "
                          f"{report.summary['total_compliance_checks']} compliance checks")
            except Exception as e:
                logger.error(f"Failed to scan {container.name}: {e}")
                
    except Exception as e:
        logger.error(f"Failed to scan containers: {e}")

if __name__ == "__main__":
    asyncio.run(scan_all_containers())