      // ============================================
      // NOTIFICATION PREFERENCES ENDPOINTS
      // ============================================

      // Get user notification preferences
      if (pathname === '/api/notifications/preferences' && request.method === 'GET') {
        const auth = await authenticateRequest(request, env);
        if (!auth.success) {
          return auth.error!;
        }

        try {
          // Get user preferences from database
          const result = await env.DB.prepare(`
            SELECT 
              email_notifications,
              sms_notifications,
              push_notifications,
              notification_frequency,
              marketing_emails,
              nda_notifications,
              pitch_updates,
              investment_updates,
              message_notifications,
              digest_frequency,
              quiet_hours_start,
              quiet_hours_end,
              timezone,
              updated_at
            FROM user_preferences 
            WHERE user_id = ?
          `).bind(auth.userId).first();

          // Return default preferences if none exist
          const preferences = result || {
            email_notifications: true,
            sms_notifications: false,
            push_notifications: true,
            notification_frequency: 'instant',
            marketing_emails: false,
            nda_notifications: true,
            pitch_updates: true,
            investment_updates: true,
            message_notifications: true,
            digest_frequency: 'daily',
            quiet_hours_start: null,
            quiet_hours_end: null,
            timezone: 'UTC',
            updated_at: new Date().toISOString()
          };

          return jsonResponse({
            success: true,
            preferences
          });
        } catch (error: any) {
          console.error('Get preferences error:', error);
          return serverErrorResponse("Failed to get preferences: " + error.message);
        }
      }

      // Update user notification preferences
      if (pathname === '/api/notifications/preferences' && request.method === 'PUT') {
        const auth = await authenticateRequest(request, env);
        if (!auth.success) {
          return auth.error!;
        }

        try {
          const updates = await request.json();
          const allowedFields = [
            'email_notifications', 'sms_notifications', 'push_notifications',
            'notification_frequency', 'marketing_emails', 'nda_notifications',
            'pitch_updates', 'investment_updates', 'message_notifications',
            'digest_frequency', 'quiet_hours_start', 'quiet_hours_end', 'timezone'
          ];

          // Filter to only allowed fields
          const filteredUpdates = Object.keys(updates)
            .filter(key => allowedFields.includes(key))
            .reduce((obj, key) => ({ ...obj, [key]: updates[key] }), {});

          if (Object.keys(filteredUpdates).length === 0) {
            return jsonResponse({
              success: false,
              error: 'No valid fields to update'
            }, 400);
          }

          // Build UPDATE query
          const setClause = Object.keys(filteredUpdates).map(key => `${key} = ?`).join(', ');
          const values = Object.values(filteredUpdates);
          values.push(new Date().toISOString()); // updated_at
          values.push(auth.userId); // WHERE clause

          await env.DB.prepare(`
            INSERT INTO user_preferences (user_id, ${Object.keys(filteredUpdates).join(', ')}, updated_at)
            VALUES (?, ${Object.keys(filteredUpdates).map(() => '?').join(', ')}, ?)
            ON CONFLICT(user_id) DO UPDATE SET
            ${setClause}, updated_at = ?
          `).bind(auth.userId, ...values).run();

          return jsonResponse({
            success: true,
            message: 'Preferences updated successfully'
          });
        } catch (error: any) {
          console.error('Update preferences error:', error);
          return serverErrorResponse("Failed to update preferences: " + error.message);
        }
      }

      // ============================================
      // TWILIO WEBHOOK ENDPOINTS
      // ============================================
      
      // Twilio SMS status webhook
      if (pathname === '/webhooks/twilio/status' && request.method === 'POST') {
        try {
          // Validate Twilio signature
          const signature = request.headers.get('X-Twilio-Signature');
          const authToken = env.TWILIO_AUTH_TOKEN;
          
          if (!signature || !authToken) {
            return new Response('Unauthorized', { status: 401 });
          }

          const body = await request.formData();
          const messageStatus = body.get('MessageStatus');
          const messageSid = body.get('MessageSid');
          const errorCode = body.get('ErrorCode');

          // Log status update
          console.log(`SMS ${messageSid}: ${messageStatus}`, errorCode ? `Error: ${errorCode}` : '');

          // Update metrics in KV/Redis
          if (messageStatus === 'delivered') {
            // Increment delivered counter
            const current = await env.KV?.get('sms:metrics:delivered') || '0';
            await env.KV?.put('sms:metrics:delivered', String(parseInt(current) + 1));
          } else if (messageStatus === 'undelivered' || messageStatus === 'failed') {
            // Increment failed counter
            const current = await env.KV?.get('sms:metrics:failed') || '0';
            await env.KV?.put('sms:metrics:failed', String(parseInt(current) + 1));
            
            if (errorCode) {
              const errorKey = `sms:errors:${errorCode}`;
              const currentErrors = await env.KV?.get(errorKey) || '0';
              await env.KV?.put(errorKey, String(parseInt(currentErrors) + 1));
            }
          }

          return new Response('OK', { status: 200 });
        } catch (error) {
          console.error('Twilio webhook error:', error);
          return new Response('Error', { status: 500 });
        }
      }

      // Twilio incoming SMS webhook
      if (pathname === '/webhooks/twilio/incoming' && request.method === 'POST') {
        try {
          const signature = request.headers.get('X-Twilio-Signature');
          const authToken = env.TWILIO_AUTH_TOKEN;
          
          if (!signature || !authToken) {
            return new Response('Unauthorized', { status: 401 });
          }

          const body = await request.formData();
          const from = body.get('From');
          const messageBody = (body.get('Body') || '').toString().toLowerCase().trim();

          console.log(`Incoming SMS from ${from}: ${messageBody}`);

          // Handle opt-out keywords
          const optOutKeywords = ['stop', 'unsubscribe', 'cancel', 'quit', 'end'];
          if (optOutKeywords.includes(messageBody)) {
            // Add to opt-out list
            await env.KV?.put(`sms:optout:${from}`, 'true');
            console.log(`User ${from} opted out of SMS`);
          }

          // Handle opt-in keywords
          const optInKeywords = ['start', 'subscribe', 'yes', 'unstop'];
          if (optInKeywords.includes(messageBody)) {
            // Remove from opt-out list
            await env.KV?.delete(`sms:optout:${from}`);
            console.log(`User ${from} opted in to SMS`);
          }

          // Handle verification codes (6-digit numbers)
          if (/^\d{6}$/.test(messageBody)) {
            // Store verification code for 5 minutes
            await env.KV?.put(`verify:sms:${from}`, messageBody, { expirationTtl: 300 });
            console.log(`Verification code ${messageBody} received from ${from}`);
          }

          return new Response('OK', { status: 200 });
        } catch (error) {
          console.error('Twilio incoming webhook error:', error);
          return new Response('Error', { status: 500 });
        }
      }

      // Test SMS endpoint
      if (pathname === '/api/sms/test' && request.method === 'POST') {
        const auth = await authenticateRequest(request, env);
        if (!auth.success) {
          return auth.error!;
        }

        try {
          const { to, message } = await request.json();
          
          if (!to || !message) {
            return jsonResponse({
              success: false,
              error: 'Missing required fields: to, message'
            }, 400);
          }

          // For now, just simulate sending
          console.log(`Test SMS to ${to}: ${message}`);

          return jsonResponse({
            success: true,
            message: 'Test SMS queued for delivery',
            sid: 'test_' + Math.random().toString(36).substr(2, 9)
          });
        } catch (error: any) {
          console.error('Test SMS error:', error);
          return serverErrorResponse("Failed to send test SMS: " + error.message);
        }
      }

      // ============================================
      // NOTIFICATION TEMPLATES ENDPOINTS
      // ============================================
      
      // Get notification templates
      if (pathname === '/api/notifications/templates' && request.method === 'GET') {
        const auth = await authenticateRequest(request, env);
        if (!auth.success || auth.role !== 'admin') {
          return new Response(JSON.stringify({
            success: false,
            error: 'Admin privileges required'
          }), { 
            status: 403, 
            headers: { 'Content-Type': 'application/json', ...corsHeaders } 
          });
        }

        const category = url.searchParams.get('category');
        const channel = url.searchParams.get('channel');
        
        try {
          let query = `
            SELECT * FROM notification_templates 
            WHERE 1=1
          `;
          const params = [];
          
          if (category) {
            query += ` AND category = ?`;
            params.push(category);
          }
          if (channel) {
            query += ` AND channel = ?`;
            params.push(channel);
          }
          
          query += ` ORDER BY created_at DESC`;

          const templates = await env.DB.prepare(query).bind(...params).all();

          return jsonResponse({
            success: true,
            templates: templates.results || []
          });
        } catch (error: any) {
          console.error('Get templates error:', error);
          return serverErrorResponse("Failed to get templates: " + error.message);
        }
      }

      // Create notification template
      if (pathname === '/api/notifications/templates' && request.method === 'POST') {
        const auth = await authenticateRequest(request, env);
        if (!auth.success || auth.role !== 'admin') {
          return new Response(JSON.stringify({
            success: false,
            error: 'Admin privileges required'
          }), { 
            status: 403, 
            headers: { 'Content-Type': 'application/json', ...corsHeaders } 
          });
        }

        try {
          const template = await request.json();
          const { name, category, channel, subject, body, variables, metadata } = template;

          if (!name || !category || !channel || !body) {
            return jsonResponse({
              success: false,
              error: 'Missing required fields'
            }, 400);
          }

          const result = await env.DB.prepare(`
            INSERT INTO notification_templates (
              name, category, channel, subject, body, variables, metadata,
              created_by, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).bind(
            name, category, channel, subject, body,
            JSON.stringify(variables || []),
            JSON.stringify(metadata || {}),
            auth.userId,
            new Date().toISOString(),
            new Date().toISOString()
          ).run();

          return jsonResponse({
            success: true,
            templateId: result.meta.last_row_id,
            message: 'Template created successfully'
          });
        } catch (error: any) {
          console.error('Create template error:', error);
          return serverErrorResponse("Failed to create template: " + error.message);
        }
      }

      // Update notification template
      if (pathname.startsWith('/api/notifications/templates/') && request.method === 'PUT') {
        const auth = await authenticateRequest(request, env);
        if (!auth.success || auth.role !== 'admin') {
          return new Response(JSON.stringify({
            success: false,
            error: 'Admin privileges required'
          }), { 
            status: 403, 
            headers: { 'Content-Type': 'application/json', ...corsHeaders } 
          });
        }

        const templateId = pathname.split('/').pop();
        
        try {
          const updates = await request.json();
          const allowedFields = ['name', 'category', 'subject', 'body', 'variables', 'metadata', 'is_active'];
          
          const filteredUpdates = Object.keys(updates)
            .filter(key => allowedFields.includes(key))
            .reduce((obj, key) => ({ ...obj, [key]: updates[key] }), {});

          if (Object.keys(filteredUpdates).length === 0) {
            return jsonResponse({
              success: false,
              error: 'No valid fields to update'
            }, 400);
          }

          const setClause = Object.keys(filteredUpdates).map(key => `${key} = ?`).join(', ');
          const values = Object.values(filteredUpdates).map(val => 
            typeof val === 'object' ? JSON.stringify(val) : val
          );
          values.push(new Date().toISOString()); // updated_at
          values.push(templateId); // WHERE clause

          await env.DB.prepare(`
            UPDATE notification_templates 
            SET ${setClause}, updated_at = ?
            WHERE id = ?
          `).bind(...values).run();

          return jsonResponse({
            success: true,
            message: 'Template updated successfully'
          });
        } catch (error: any) {
          console.error('Update template error:', error);
          return serverErrorResponse("Failed to update template: " + error.message);
        }
      }

      // Delete notification template
      if (pathname.startsWith('/api/notifications/templates/') && request.method === 'DELETE') {
        const auth = await authenticateRequest(request, env);
        if (!auth.success || auth.role !== 'admin') {
          return new Response(JSON.stringify({
            success: false,
            error: 'Admin privileges required'
          }), { 
            status: 403, 
            headers: { 'Content-Type': 'application/json', ...corsHeaders } 
          });
        }

        const templateId = pathname.split('/').pop();
        
        try {
          await env.DB.prepare(`
            DELETE FROM notification_templates WHERE id = ?
          `).bind(templateId).run();

          return jsonResponse({
            success: true,
            message: 'Template deleted successfully'
          });
        } catch (error: any) {
          console.error('Delete template error:', error);
          return serverErrorResponse("Failed to delete template: " + error.message);
        }
      }