name: Production Deployment - Final with All Optimizations

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (emergency deployment only)'
        required: false
        default: 'false'
        type: boolean
      force_deploy:
        description: 'Force deployment (bypass checks)'
        required: false
        default: 'false'
        type: boolean
      rollback_version:
        description: 'Rollback to specific version'
        required: false
        default: ''
        type: string

env:
  NODE_VERSION: '20'
  DENO_VERSION: '1.40.0'
  CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
  CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
  HYPERDRIVE_ID: ${{ secrets.HYPERDRIVE_ID }}
  SENTRY_DSN: ${{ secrets.SENTRY_DSN }}

jobs:
  # Phase 1: Pre-deployment validation
  pre_deployment_checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      version: ${{ steps.version.outputs.version }}
      should_deploy: ${{ steps.checks.outputs.should_deploy }}
      cache_key: ${{ steps.cache.outputs.cache_key }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: ${{ env.DENO_VERSION }}

      - name: Generate version
        id: version
        run: |
          VERSION="v$(date +%Y%m%d)-$(git rev-parse --short HEAD)"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Cache dependencies
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            ~/.deno
            node_modules
            frontend/node_modules
          key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json', '**/deno.lock') }}
          restore-keys: |
            ${{ runner.os }}-deps-

      - name: Install dependencies
        run: |
          npm ci
          cd frontend && npm ci

      - name: Environment validation
        run: |
          echo "Validating environment configuration..."
          
          # Check required secrets exist
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then
            echo "‚ùå Missing JWT_SECRET"
            exit 1
          fi
          
          if [ -z "${{ secrets.DATABASE_URL }}" ]; then
            echo "‚ùå Missing DATABASE_URL"
            exit 1
          fi
          
          if [ -z "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]; then
            echo "‚ùå Missing CLOUDFLARE_API_TOKEN"
            exit 1
          fi
          
          echo "‚úÖ All required secrets configured"

      - name: Security scan
        run: |
          echo "Running security scan..."
          npm audit --audit-level=high
          cd frontend && npm audit --audit-level=high

      - name: Deployment readiness check
        id: checks
        run: |
          SHOULD_DEPLOY="true"
          
          # Skip deployment for draft PRs
          if [ "${{ github.event.pull_request.draft }}" = "true" ]; then
            SHOULD_DEPLOY="false"
            echo "Draft PR - skipping deployment"
          fi
          
          # Force deploy if requested
          if [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            SHOULD_DEPLOY="true"
            echo "Force deploy requested"
          fi
          
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT

  # Phase 2: Testing suite
  run_tests:
    name: Comprehensive Testing
    runs-on: ubuntu-latest
    needs: pre_deployment_checks
    if: needs.pre_deployment_checks.outputs.should_deploy == 'true' && github.event.inputs.skip_tests != 'true'
    timeout-minutes: 20
    
    strategy:
      matrix:
        test-suite: [unit, integration, e2e]
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup test environment
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: ${{ env.DENO_VERSION }}

      - name: Restore dependencies cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            ~/.deno
            node_modules
            frontend/node_modules
          key: ${{ needs.pre_deployment_checks.outputs.cache_key }}

      - name: Install dependencies
        run: |
          npm ci
          cd frontend && npm ci

      - name: Run unit tests
        if: matrix.test-suite == 'unit'
        run: |
          echo "Running unit tests..."
          cd frontend && npm run test:unit
          echo "Backend unit tests..."
          deno test --allow-all tests/unit/

      - name: Run integration tests
        if: matrix.test-suite == 'integration'
        env:
          DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
        run: |
          echo "Running integration tests..."
          deno test --allow-all tests/integration/

      - name: Run E2E tests
        if: matrix.test-suite == 'e2e'
        run: |
          echo "Running E2E tests..."
          cd frontend && npm run test:e2e:ci

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.test-suite }}
          path: |
            test-results/
            coverage/
            playwright-report/

  # Phase 3: Performance baseline
  performance_baseline:
    name: Performance Baseline
    runs-on: ubuntu-latest
    needs: pre_deployment_checks
    if: needs.pre_deployment_checks.outputs.should_deploy == 'true'
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install K6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Run performance tests
        run: |
          echo "Capturing performance baseline..."
          
          # API load test
          k6 run --out json=performance-api.json performance/k6/api-load-test.js || true
          
          # Database stress test
          k6 run --out json=performance-db.json performance/k6/database-stress-test.js || true

      - name: Store baseline metrics
        run: |
          echo "Storing performance baseline for comparison..."
          mkdir -p performance-results
          cp performance-*.json performance-results/
          echo "$(date): Performance baseline captured" >> performance-results/baseline.log

      - name: Upload performance results
        uses: actions/upload-artifact@v4
        with:
          name: performance-baseline
          path: performance-results/

  # Phase 4: Build and optimize
  build_and_optimize:
    name: Build and Optimize
    runs-on: ubuntu-latest
    needs: [pre_deployment_checks, run_tests]
    if: always() && needs.pre_deployment_checks.outputs.should_deploy == 'true' && (needs.run_tests.result == 'success' || github.event.inputs.skip_tests == 'true')
    timeout-minutes: 15
    outputs:
      build_hash: ${{ steps.build.outputs.build_hash }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: ${{ env.DENO_VERSION }}

      - name: Install dependencies
        run: |
          npm ci
          cd frontend && npm ci

      - name: Apply optimizations
        run: |
          echo "Applying performance optimizations..."
          
          # Apply database optimizations
          if [ -f "optimization-patches/db-optimization.patch" ]; then
            git apply optimization-patches/db-optimization.patch || true
          fi
          
          # Apply cache optimizations
          if [ -f "optimization-patches/cache-optimization.patch" ]; then
            git apply optimization-patches/cache-optimization.patch || true
          fi

      - name: Build frontend
        run: |
          echo "Building optimized frontend..."
          cd frontend
          npm run build
          
          # Verify build output
          ls -la dist/
          
          # Check bundle size
          npm run analyze-bundle || true

      - name: Build worker
        id: build
        run: |
          echo "Preparing worker deployment..."
          
          # Generate build hash for deployment tracking
          BUILD_HASH=$(find src/ -type f -exec sha256sum {} \; | sha256sum | cut -d' ' -f1)
          echo "build_hash=$BUILD_HASH" >> $GITHUB_OUTPUT
          echo "Build hash: $BUILD_HASH"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            src/
            frontend/dist/
            wrangler.toml

  # Phase 5: Staging deployment
  deploy_staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [pre_deployment_checks, build_and_optimize]
    if: github.event_name == 'pull_request' && needs.pre_deployment_checks.outputs.should_deploy == 'true'
    timeout-minutes: 10
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Setup Wrangler
        run: |
          npm install -g wrangler@latest
          wrangler --version

      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment..."
          
          # Create staging-specific wrangler.toml
          cp wrangler.toml wrangler.staging.toml
          sed -i 's/pitchey-production/pitchey-staging/g' wrangler.staging.toml
          sed -i 's/ENVIRONMENT = "production"/ENVIRONMENT = "staging"/g' wrangler.staging.toml
          
          # Deploy to staging
          wrangler deploy --config wrangler.staging.toml --env staging
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Staging health check
        run: |
          echo "Verifying staging deployment..."
          sleep 30
          
          # Health check
          curl -f "https://pitchey-staging.cavelltheleaddev.workers.dev/api/health" || exit 1
          echo "‚úÖ Staging deployment successful"

  # Phase 6: Production deployment
  deploy_production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre_deployment_checks, build_and_optimize, performance_baseline]
    if: github.ref == 'refs/heads/main' && needs.pre_deployment_checks.outputs.should_deploy == 'true' && github.event.inputs.rollback_version == ''
    timeout-minutes: 15
    environment: 
      name: production
      url: https://pitchey-production.cavelltheleaddev.workers.dev

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Setup Wrangler
        run: |
          npm install -g wrangler@latest
          wrangler --version

      - name: Pre-deployment backup
        run: |
          echo "Creating deployment backup..."
          
          # Create deployment backup record
          echo "$(date): Pre-deployment backup for version ${{ needs.pre_deployment_checks.outputs.version }}" >> deployment-backups.log
          
          # Backup current worker version (if exists)
          wrangler versions list --name pitchey-production > current-version.txt 2>/dev/null || true

      - name: Database migrations
        run: |
          echo "Running database migrations..."
          
          # Run pending migrations
          deno run --allow-all src/db/migrate.ts
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DENO_ENV: production

      - name: Warm cache
        run: |
          echo "Warming edge cache..."
          
          # Pre-warm cache with critical data
          if [ -f "scripts/cache-warming.sh" ]; then
            chmod +x scripts/cache-warming.sh
            ./scripts/cache-warming.sh
          fi

      - name: Deploy to production
        id: deploy
        run: |
          echo "Deploying to production..."
          
          # Deploy with zero downtime
          wrangler deploy --env production
          
          # Store deployment info
          echo "deployment_time=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT
          echo "deployment_version=${{ needs.pre_deployment_checks.outputs.version }}" >> $GITHUB_OUTPUT
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Post-deployment verification
        run: |
          echo "Verifying production deployment..."
          
          # Wait for deployment to propagate
          sleep 60
          
          # Health checks
          curl -f "https://pitchey-production.cavelltheleaddev.workers.dev/api/health" || exit 1
          curl -f "https://pitchey-production.cavelltheleaddev.workers.dev/api/health/database" || exit 1
          curl -f "https://pitchey-production.cavelltheleaddev.workers.dev/api/health/cache" || exit 1
          
          echo "‚úÖ Production deployment verified"

      - name: Deploy frontend to Cloudflare Pages
        run: |
          echo "Deploying frontend to Cloudflare Pages..."
          
          # Deploy frontend
          wrangler pages deploy frontend/dist --project-name=pitchey
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Update deployment record
        run: |
          echo "Updating deployment records..."
          
          # Create deployment record
          cat > deployment-record.json << EOF
          {
            "version": "${{ needs.pre_deployment_checks.outputs.version }}",
            "timestamp": "${{ steps.deploy.outputs.deployment_time }}",
            "commit": "${{ github.sha }}",
            "build_hash": "${{ needs.build_and_optimize.outputs.build_hash }}",
            "deployed_by": "${{ github.actor }}",
            "workflow_run": "${{ github.run_id }}"
          }
          EOF

      - name: Notify deployment success
        if: success()
        run: |
          echo "üéâ Production deployment successful!"
          echo "Version: ${{ needs.pre_deployment_checks.outputs.version }}"
          echo "Time: ${{ steps.deploy.outputs.deployment_time }}"
          echo "Build: ${{ needs.build_and_optimize.outputs.build_hash }}"

  # Phase 7: Rollback (if requested)
  rollback_production:
    name: Rollback Production
    runs-on: ubuntu-latest
    if: github.event.inputs.rollback_version != ''
    timeout-minutes: 10
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Wrangler
        run: |
          npm install -g wrangler@latest
          wrangler --version

      - name: Execute rollback
        run: |
          echo "Rolling back to version: ${{ github.event.inputs.rollback_version }}"
          
          # Get available versions
          wrangler versions list --name pitchey-production
          
          # Rollback to specified version
          wrangler rollback --name pitchey-production --version-id "${{ github.event.inputs.rollback_version }}"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Verify rollback
        run: |
          echo "Verifying rollback..."
          sleep 30
          
          # Health check after rollback
          curl -f "https://pitchey-production.cavelltheleaddev.workers.dev/api/health" || exit 1
          
          echo "‚úÖ Rollback successful"

  # Phase 8: Post-deployment monitoring
  post_deployment_monitoring:
    name: Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy_production]
    if: always() && needs.deploy_production.result == 'success'
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Monitor deployment health
        run: |
          echo "Monitoring deployment health for 30 minutes..."
          
          # Monitor key metrics
          for i in {1..30}; do
            echo "Health check $i/30..."
            
            # API health
            if ! curl -s -f "https://pitchey-production.cavelltheleaddev.workers.dev/api/health"; then
              echo "‚ùå API health check failed"
              exit 1
            fi
            
            # Database health
            if ! curl -s -f "https://pitchey-production.cavelltheleaddev.workers.dev/api/health/database"; then
              echo "‚ùå Database health check failed"
              exit 1
            fi
            
            echo "‚úÖ Health check $i passed"
            sleep 60
          done
          
          echo "‚úÖ All health checks passed - deployment stable"

      - name: Performance validation
        run: |
          echo "Validating post-deployment performance..."
          
          # Download baseline for comparison
          if [ -d "performance-results" ]; then
            echo "Comparing against baseline performance..."
            
            # Run quick performance test
            curl -w "Response time: %{time_total}s\n" -s "https://pitchey-production.cavelltheleaddev.workers.dev/api/health" > /dev/null
            
            echo "‚úÖ Performance validation complete"
          fi

  # Phase 9: A/B Testing setup
  setup_ab_testing:
    name: Setup A/B Testing
    runs-on: ubuntu-latest
    needs: [deploy_production, post_deployment_monitoring]
    if: always() && needs.deploy_production.result == 'success' && needs.post_deployment_monitoring.result == 'success'
    timeout-minutes: 5

    steps:
      - name: Configure A/B testing
        run: |
          echo "Setting up A/B testing for cache improvements..."
          
          # This would typically involve configuring feature flags
          # or traffic splitting in your CDN/load balancer
          
          echo "A/B testing configuration:"
          echo "- Control Group (A): 90% - Current implementation"
          echo "- Test Group (B): 10% - Enhanced cache optimization"
          echo "- Duration: 7 days"
          echo "- Success metric: >20% improvement in response time"
          
          echo "‚úÖ A/B testing setup complete"

  # Cleanup and notifications
  cleanup_and_notify:
    name: Cleanup and Notify
    runs-on: ubuntu-latest
    needs: [deploy_production, post_deployment_monitoring, setup_ab_testing]
    if: always()
    timeout-minutes: 5

    steps:
      - name: Cleanup artifacts
        run: |
          echo "Cleaning up deployment artifacts..."
          # Cleanup would happen automatically, but we can log it
          echo "‚úÖ Cleanup complete"

      - name: Send deployment notification
        if: needs.deploy_production.result == 'success'
        run: |
          echo "Sending deployment success notification..."
          
          # This would integrate with Slack, Discord, email, etc.
          echo "üöÄ Production deployment successful!"
          echo "Version: ${{ needs.pre_deployment_checks.outputs.version }}"
          echo "All systems operational"

      - name: Send failure notification
        if: needs.deploy_production.result == 'failure'
        run: |
          echo "Sending deployment failure notification..."
          
          echo "‚ùå Production deployment failed!"
          echo "Manual intervention required"
          exit 1