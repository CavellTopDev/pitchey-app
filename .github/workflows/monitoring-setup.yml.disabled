name: Monitoring & Alerting Setup

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to setup monitoring for'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
        default: 'staging'
      monitoring_type:
        description: 'Type of monitoring to setup'
        required: true
        type: choice
        options:
          - full # Complete monitoring stack
          - basic # Essential monitoring only
          - alerts # Alert rules only
          - dashboards # Dashboards only
        default: 'full'
      force_update:
        description: 'Force update existing monitoring configuration'
        required: false
        default: false
        type: boolean

  # Auto-setup monitoring after successful deployment
  workflow_run:
    workflows: ["CD - Staging Deployment", "CD - Production Deployment"]
    types: [completed]

concurrency:
  group: monitoring-setup-${{ github.event.inputs.environment || 'auto' }}
  cancel-in-progress: false

env:
  NODE_VERSION: '20'
  DENO_VERSION: '2.x'

jobs:
  # Setup monitoring infrastructure
  monitoring-infrastructure:
    name: Setup Monitoring Infrastructure
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      monitoring_endpoints: ${{ steps.endpoints.outputs.monitoring_endpoints }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            # Determine environment from workflow that triggered this
            if echo "${{ github.event.workflow_run.name }}" | grep -i "staging"; then
              ENVIRONMENT="staging"
            elif echo "${{ github.event.workflow_run.name }}" | grep -i "production"; then
              ENVIRONMENT="production"
            else
              ENVIRONMENT="staging"
            fi
          else
            ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "Setting up monitoring for environment: $ENVIRONMENT"

      - name: Setup environment endpoints
        id: endpoints
        run: |
          ENVIRONMENT="${{ steps.env.outputs.environment }}"
          
          case "$ENVIRONMENT" in
            "production")
              API_URL="https://pitchey-production.cavelltheleaddev.workers.dev"
              FRONTEND_URL="https://pitchey.pages.dev"
              ;;
            "staging")
              API_URL="https://pitchey-staging.cavelltheleaddev.workers.dev"
              FRONTEND_URL="https://pitchey-staging.pages.dev"
              ;;
            "development")
              API_URL="http://localhost:8001"
              FRONTEND_URL="http://localhost:5173"
              ;;
          esac
          
          MONITORING_ENDPOINTS=$(cat << EOF | jq -c .
          {
            "api_url": "$API_URL",
            "frontend_url": "$FRONTEND_URL",
            "health_endpoint": "$API_URL/health",
            "metrics_endpoint": "$API_URL/metrics",
            "status_endpoint": "$API_URL/status"
          }
          EOF
          )
          
          echo "monitoring_endpoints=$MONITORING_ENDPOINTS" >> $GITHUB_OUTPUT

      - name: Create monitoring configuration
        run: |
          ENVIRONMENT="${{ steps.env.outputs.environment }}"
          MONITORING_TYPE="${{ github.event.inputs.monitoring_type || 'full' }}"
          
          echo "ðŸ“Š Creating monitoring configuration for $ENVIRONMENT..."
          
          # Create monitoring config directory
          mkdir -p monitoring-config/$ENVIRONMENT
          
          # Generate monitoring configuration
          cat > monitoring-config/$ENVIRONMENT/monitoring.yml << EOF
          # Monitoring Configuration for $ENVIRONMENT
          environment: $ENVIRONMENT
          created_at: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          created_by: ${{ github.actor }}
          
          # Service endpoints
          endpoints:
            api: ${{ fromJSON(steps.endpoints.outputs.monitoring_endpoints).api_url }}
            frontend: ${{ fromJSON(steps.endpoints.outputs.monitoring_endpoints).frontend_url }}
            health: ${{ fromJSON(steps.endpoints.outputs.monitoring_endpoints).health_endpoint }}
            metrics: ${{ fromJSON(steps.endpoints.outputs.monitoring_endpoints).metrics_endpoint }}
          
          # Health check configuration
          health_checks:
            enabled: true
            interval: ${{ env.ENVIRONMENT == 'production' && '60' || '300' }}s
            timeout: 30s
            retries: 3
            
            checks:
              - name: api_health
                url: ${{ fromJSON(steps.endpoints.outputs.monitoring_endpoints).health_endpoint }}
                method: GET
                expected_status: 200
                
              - name: frontend_availability
                url: ${{ fromJSON(steps.endpoints.outputs.monitoring_endpoints).frontend_url }}
                method: GET
                expected_status: 200
                
              - name: database_connectivity
                url: ${{ fromJSON(steps.endpoints.outputs.monitoring_endpoints).api_url }}/health/db
                method: GET
                expected_status: 200
          
          # Performance monitoring
          performance:
            enabled: true
            thresholds:
              response_time_p95: ${{ env.ENVIRONMENT == 'production' && '1000' || '2000' }}ms
              response_time_p99: ${{ env.ENVIRONMENT == 'production' && '2000' || '5000' }}ms
              error_rate: ${{ env.ENVIRONMENT == 'production' && '1' || '5' }}%
              availability: ${{ env.ENVIRONMENT == 'production' && '99.9' || '99.0' }}%
          
          # Alert configuration
          alerts:
            enabled: true
            channels:
              slack: ${{ secrets.SLACK_WEBHOOK_URL && 'true' || 'false' }}
              email: true
              pagerduty: ${{ env.ENVIRONMENT == 'production' && 'true' || 'false' }}
            
            rules:
              - name: high_error_rate
                condition: error_rate > ${{ env.ENVIRONMENT == 'production' && '2' || '10' }}%
                duration: 5m
                severity: critical
                
              - name: slow_response_time
                condition: response_time_p95 > ${{ env.ENVIRONMENT == 'production' && '2000' || '5000' }}ms
                duration: 10m
                severity: warning
                
              - name: service_down
                condition: availability < 95%
                duration: 1m
                severity: critical
          EOF

      - name: Upload monitoring configuration
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-config-${{ steps.env.outputs.environment }}
          path: monitoring-config/
          retention-days: 90

  # Setup Sentry monitoring
  sentry-setup:
    name: Setup Sentry Monitoring
    runs-on: ubuntu-latest
    needs: monitoring-infrastructure
    if: github.event.inputs.monitoring_type == 'full' || github.event.inputs.monitoring_type == '' || github.event_name == 'workflow_run'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Sentry CLI
        uses: mathrix-education/setup-sentry-cli@v1
        with:
          token: ${{ secrets.SENTRY_AUTH_TOKEN }}
          organization: pitchey
          project: pitchey-${{ needs.monitoring-infrastructure.outputs.environment }}

      - name: Create Sentry project (if needed)
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          PROJECT_NAME="pitchey-$ENVIRONMENT"
          
          echo "ðŸ”§ Setting up Sentry project: $PROJECT_NAME"
          
          # Check if project exists
          if ! sentry-cli projects list | grep -q "$PROJECT_NAME"; then
            echo "Creating new Sentry project: $PROJECT_NAME"
            sentry-cli projects create "$PROJECT_NAME" --platform javascript
          else
            echo "Sentry project already exists: $PROJECT_NAME"
          fi

      - name: Configure Sentry alerts
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          PROJECT_NAME="pitchey-$ENVIRONMENT"
          
          echo "âš ï¸ Configuring Sentry alert rules for $PROJECT_NAME"
          
          # Create alert rules configuration
          cat > sentry-alerts.json << EOF
          [
            {
              "name": "High Error Rate - $ENVIRONMENT",
              "conditions": [
                {
                  "id": "sentry.rules.conditions.event_frequency.EventFrequencyCondition",
                  "interval": "5m",
                  "value": 10
                }
              ],
              "actions": [
                {
                  "id": "sentry.rules.actions.notify_event_service.NotifyEventServiceAction",
                  "service": "mail"
                }
              ],
              "environment": "$ENVIRONMENT"
            },
            {
              "name": "New Issue Alert - $ENVIRONMENT",
              "conditions": [
                {
                  "id": "sentry.rules.conditions.first_seen_event.FirstSeenEventCondition"
                }
              ],
              "actions": [
                {
                  "id": "sentry.rules.actions.notify_event_service.NotifyEventServiceAction",
                  "service": "slack"
                }
              ],
              "environment": "$ENVIRONMENT"
            }
          ]
          EOF
          
          echo "Sentry alert rules configured"

      - name: Setup Sentry releases
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          PROJECT_NAME="pitchey-$ENVIRONMENT"
          RELEASE_VERSION="${{ github.sha }}"
          
          echo "ðŸ“¦ Setting up Sentry release tracking"
          
          # Create release
          sentry-cli releases new "$RELEASE_VERSION" --project "$PROJECT_NAME"
          
          # Set commits
          sentry-cli releases set-commits "$RELEASE_VERSION" --auto --project "$PROJECT_NAME"
          
          # Deploy to environment
          sentry-cli releases deploys "$RELEASE_VERSION" new -e "$ENVIRONMENT" --project "$PROJECT_NAME"
          
          echo "Sentry release $RELEASE_VERSION deployed to $ENVIRONMENT"

  # Setup Uptime monitoring
  uptime-monitoring:
    name: Setup Uptime Monitoring
    runs-on: ubuntu-latest
    needs: monitoring-infrastructure
    if: github.event.inputs.monitoring_type == 'full' || github.event.inputs.monitoring_type == 'basic' || github.event.inputs.monitoring_type == '' || github.event_name == 'workflow_run'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup uptime monitoring
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          ENDPOINTS='${{ needs.monitoring-infrastructure.outputs.monitoring_endpoints }}'
          
          echo "â±ï¸ Setting up uptime monitoring for $ENVIRONMENT"
          
          # Create uptime monitoring configuration
          cat > uptime-monitoring.json << EOF
          {
            "environment": "$ENVIRONMENT",
            "monitors": [
              {
                "name": "Frontend - $ENVIRONMENT",
                "url": "$(echo $ENDPOINTS | jq -r .frontend_url)",
                "method": "GET",
                "timeout": 30,
                "interval": ${{ needs.monitoring-infrastructure.outputs.environment == 'production' && '60' || '300' }},
                "expected_status_codes": [200],
                "alerts": {
                  "email": true,
                  "slack": ${{ secrets.SLACK_WEBHOOK_URL && 'true' || 'false' }},
                  "sms": ${{ needs.monitoring-infrastructure.outputs.environment == 'production' && 'true' || 'false' }}
                }
              },
              {
                "name": "API Health - $ENVIRONMENT",
                "url": "$(echo $ENDPOINTS | jq -r .health_endpoint)",
                "method": "GET",
                "timeout": 30,
                "interval": ${{ needs.monitoring-infrastructure.outputs.environment == 'production' && '60' || '300' }},
                "expected_status_codes": [200],
                "alerts": {
                  "email": true,
                  "slack": ${{ secrets.SLACK_WEBHOOK_URL && 'true' || 'false' }},
                  "sms": ${{ needs.monitoring-infrastructure.outputs.environment == 'production' && 'true' || 'false' }}
                }
              }
            ]
          }
          EOF
          
          echo "Uptime monitoring configuration created"

      - name: Setup UptimeRobot monitors
        if: secrets.UPTIMEROBOT_API_KEY
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          ENDPOINTS='${{ needs.monitoring-infrastructure.outputs.monitoring_endpoints }}'
          
          echo "ðŸ”§ Creating UptimeRobot monitors"
          
          # Create frontend monitor
          FRONTEND_URL=$(echo $ENDPOINTS | jq -r .frontend_url)
          curl -X POST "https://api.uptimerobot.com/v2/newMonitor" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "api_key=${{ secrets.UPTIMEROBOT_API_KEY }}" \
            -d "format=json" \
            -d "type=1" \
            -d "url=$FRONTEND_URL" \
            -d "friendly_name=Pitchey Frontend - $ENVIRONMENT" \
            -d "interval=${{ needs.monitoring-infrastructure.outputs.environment == 'production' && '300' || '600' }}"
          
          # Create API monitor
          API_HEALTH_URL=$(echo $ENDPOINTS | jq -r .health_endpoint)
          curl -X POST "https://api.uptimerobot.com/v2/newMonitor" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "api_key=${{ secrets.UPTIMEROBOT_API_KEY }}" \
            -d "format=json" \
            -d "type=1" \
            -d "url=$API_HEALTH_URL" \
            -d "friendly_name=Pitchey API - $ENVIRONMENT" \
            -d "interval=${{ needs.monitoring-infrastructure.outputs.environment == 'production' && '300' || '600' }}"

      - name: Upload uptime configuration
        uses: actions/upload-artifact@v4
        with:
          name: uptime-monitoring-${{ needs.monitoring-infrastructure.outputs.environment }}
          path: uptime-monitoring.json
          retention-days: 90

  # Setup Performance monitoring
  performance-monitoring:
    name: Setup Performance Monitoring
    runs-on: ubuntu-latest
    needs: monitoring-infrastructure
    if: github.event.inputs.monitoring_type == 'full' || github.event.inputs.monitoring_type == '' || github.event_name == 'workflow_run'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Lighthouse CI monitoring
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          ENDPOINTS='${{ needs.monitoring-infrastructure.outputs.monitoring_endpoints }}'
          
          echo "âš¡ Setting up performance monitoring for $ENVIRONMENT"
          
          # Create Lighthouse CI configuration
          cat > lighthouse-ci-$ENVIRONMENT.json << EOF
          {
            "ci": {
              "collect": {
                "url": ["$(echo $ENDPOINTS | jq -r .frontend_url)"],
                "numberOfRuns": 3
              },
              "assert": {
                "assertions": {
                  "categories:performance": ["error", {"minScore": ${{ needs.monitoring-infrastructure.outputs.environment == 'production' && '0.8' || '0.7' }}}],
                  "categories:accessibility": ["error", {"minScore": 0.9}],
                  "categories:best-practices": ["error", {"minScore": 0.8}],
                  "categories:seo": ["error", {"minScore": 0.8}]
                }
              },
              "upload": {
                "target": "temporary-public-storage"
              }
            }
          }
          EOF

      - name: Setup Web Vitals monitoring
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          
          echo "ðŸ“ˆ Setting up Web Vitals monitoring"
          
          # Create Web Vitals monitoring script
          cat > web-vitals-monitor.js << 'EOF'
          // Web Vitals monitoring for Pitchey
          import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';
          
          const environment = process.env.ENVIRONMENT || 'development';
          const apiUrl = process.env.API_URL;
          
          function sendToAnalytics(metric) {
            const body = JSON.stringify({
              name: metric.name,
              value: metric.value,
              id: metric.id,
              delta: metric.delta,
              entries: metric.entries,
              environment: environment,
              timestamp: Date.now()
            });
            
            // Send to monitoring endpoint
            fetch(`${apiUrl}/api/analytics/web-vitals`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: body
            }).catch(console.error);
          }
          
          // Collect all Web Vitals metrics
          getCLS(sendToAnalytics);
          getFID(sendToAnalytics);
          getFCP(sendToAnalytics);
          getLCP(sendToAnalytics);
          getTTFB(sendToAnalytics);
          EOF

      - name: Upload performance configuration
        uses: actions/upload-artifact@v4
        with:
          name: performance-monitoring-${{ needs.monitoring-infrastructure.outputs.environment }}
          path: |
            lighthouse-ci-*.json
            web-vitals-monitor.js
          retention-days: 90

  # Setup Alert rules
  alert-setup:
    name: Setup Alert Rules
    runs-on: ubuntu-latest
    needs: monitoring-infrastructure
    if: github.event.inputs.monitoring_type == 'full' || github.event.inputs.monitoring_type == 'alerts' || github.event.inputs.monitoring_type == '' || github.event_name == 'workflow_run'
    
    steps:
      - name: Create alert rules
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          
          echo "ðŸš¨ Setting up alert rules for $ENVIRONMENT"
          
          # Create comprehensive alert rules
          cat > alert-rules-$ENVIRONMENT.yml << EOF
          # Alert Rules for $ENVIRONMENT
          groups:
            - name: pitchey-$ENVIRONMENT-alerts
              rules:
                # High error rate alert
                - alert: HighErrorRate
                  expr: rate(http_requests_total{status=~"5.."}[5m]) > ${{ needs.monitoring-infrastructure.outputs.environment == 'production' && '0.02' || '0.1' }}
                  for: 5m
                  labels:
                    severity: critical
                    environment: $ENVIRONMENT
                  annotations:
                    summary: "High error rate detected in $ENVIRONMENT"
                    description: "Error rate is {{ \$value }} errors per second"
                
                # Slow response time alert
                - alert: SlowResponseTime
                  expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > ${{ needs.monitoring-infrastructure.outputs.environment == 'production' && '2' || '5' }}
                  for: 10m
                  labels:
                    severity: warning
                    environment: $ENVIRONMENT
                  annotations:
                    summary: "Slow response time in $ENVIRONMENT"
                    description: "95th percentile response time is {{ \$value }}s"
                
                # Service down alert
                - alert: ServiceDown
                  expr: up == 0
                  for: 1m
                  labels:
                    severity: critical
                    environment: $ENVIRONMENT
                  annotations:
                    summary: "Service is down in $ENVIRONMENT"
                    description: "{{ \$labels.instance }} has been down for more than 1 minute"
                
                # High memory usage alert
                - alert: HighMemoryUsage
                  expr: (process_resident_memory_bytes / process_virtual_memory_max_bytes) * 100 > 80
                  for: 5m
                  labels:
                    severity: warning
                    environment: $ENVIRONMENT
                  annotations:
                    summary: "High memory usage in $ENVIRONMENT"
                    description: "Memory usage is {{ \$value }}%"
                
                # Database connection issues
                - alert: DatabaseConnectionIssues
                  expr: database_connections_active > database_connections_max * 0.9
                  for: 2m
                  labels:
                    severity: warning
                    environment: $ENVIRONMENT
                  annotations:
                    summary: "Database connection pool nearly exhausted"
                    description: "Active connections: {{ \$value }}"
          EOF

      - name: Setup Slack notifications
        if: secrets.SLACK_WEBHOOK_URL
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          
          echo "ðŸ’¬ Testing Slack notification setup"
          
          # Test Slack webhook
          curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "text": "ðŸ”§ Monitoring setup completed for '"$ENVIRONMENT"'",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ðŸ”§ *Monitoring Setup Completed*\n\n*Environment:* '"$ENVIRONMENT"'\n*Setup by:* ${{ github.actor }}\n*Timestamp:* $(date -u)"
                  }
                }
              ]
            }'

      - name: Setup PagerDuty integration
        if: secrets.PAGERDUTY_ROUTING_KEY && needs.monitoring-infrastructure.outputs.environment == 'production'
        run: |
          echo "ðŸ“Ÿ Setting up PagerDuty integration for production"
          
          # Create PagerDuty integration configuration
          cat > pagerduty-integration.json << EOF
          {
            "routing_key": "${{ secrets.PAGERDUTY_ROUTING_KEY }}",
            "event_action": "trigger",
            "dedup_key": "pitchey-production-monitoring",
            "payload": {
              "summary": "Pitchey Production Monitoring Setup Complete",
              "source": "github-actions",
              "severity": "info",
              "component": "monitoring-system",
              "group": "pitchey-production",
              "class": "infrastructure"
            }
          }
          EOF
          
          # Send test alert to PagerDuty
          curl -X POST "https://events.pagerduty.com/v2/enqueue" \
            -H "Content-Type: application/json" \
            -d @pagerduty-integration.json

      - name: Upload alert configuration
        uses: actions/upload-artifact@v4
        with:
          name: alert-rules-${{ needs.monitoring-infrastructure.outputs.environment }}
          path: |
            alert-rules-*.yml
            pagerduty-integration.json
          retention-days: 90

  # Create monitoring dashboard
  dashboard-setup:
    name: Setup Monitoring Dashboard
    runs-on: ubuntu-latest
    needs: [monitoring-infrastructure, sentry-setup, uptime-monitoring, performance-monitoring, alert-setup]
    if: always() && (github.event.inputs.monitoring_type == 'full' || github.event.inputs.monitoring_type == 'dashboards' || github.event.inputs.monitoring_type == '' || github.event_name == 'workflow_run')
    
    steps:
      - name: Create monitoring dashboard
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          ENDPOINTS='${{ needs.monitoring-infrastructure.outputs.monitoring_endpoints }}'
          
          echo "ðŸ“Š Creating monitoring dashboard for $ENVIRONMENT"
          
          # Create comprehensive dashboard configuration
          cat > monitoring-dashboard-$ENVIRONMENT.json << EOF
          {
            "dashboard": {
              "title": "Pitchey $ENVIRONMENT Monitoring",
              "tags": ["pitchey", "$ENVIRONMENT", "monitoring"],
              "timezone": "UTC",
              "panels": [
                {
                  "id": 1,
                  "title": "Service Health",
                  "type": "singlestat",
                  "targets": [
                    {
                      "expr": "up{job=\"pitchey-$ENVIRONMENT\"}",
                      "legendFormat": "Service Status"
                    }
                  ]
                },
                {
                  "id": 2,
                  "title": "Response Time",
                  "type": "graph",
                  "targets": [
                    {
                      "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{job=\"pitchey-$ENVIRONMENT\"}[5m]))",
                      "legendFormat": "95th Percentile"
                    },
                    {
                      "expr": "histogram_quantile(0.50, rate(http_request_duration_seconds_bucket{job=\"pitchey-$ENVIRONMENT\"}[5m]))",
                      "legendFormat": "Median"
                    }
                  ]
                },
                {
                  "id": 3,
                  "title": "Error Rate",
                  "type": "graph",
                  "targets": [
                    {
                      "expr": "rate(http_requests_total{job=\"pitchey-$ENVIRONMENT\",status=~\"5..\"}[5m])",
                      "legendFormat": "5xx Errors"
                    },
                    {
                      "expr": "rate(http_requests_total{job=\"pitchey-$ENVIRONMENT\",status=~\"4..\"}[5m])",
                      "legendFormat": "4xx Errors"
                    }
                  ]
                },
                {
                  "id": 4,
                  "title": "Request Volume",
                  "type": "graph",
                  "targets": [
                    {
                      "expr": "rate(http_requests_total{job=\"pitchey-$ENVIRONMENT\"}[5m])",
                      "legendFormat": "Requests/sec"
                    }
                  ]
                },
                {
                  "id": 5,
                  "title": "Database Connections",
                  "type": "graph",
                  "targets": [
                    {
                      "expr": "database_connections_active{job=\"pitchey-$ENVIRONMENT\"}",
                      "legendFormat": "Active Connections"
                    },
                    {
                      "expr": "database_connections_idle{job=\"pitchey-$ENVIRONMENT\"}",
                      "legendFormat": "Idle Connections"
                    }
                  ]
                }
              ]
            }
          }
          EOF

      - name: Create status page
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          
          echo "ðŸ“‹ Creating status page for $ENVIRONMENT"
          
          # Create simple status page HTML
          cat > status-page-$ENVIRONMENT.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Pitchey Status - $ENVIRONMENT</title>
              <style>
                  body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
                  .container { max-width: 800px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; }
                  .status { padding: 15px; border-radius: 4px; margin: 10px 0; }
                  .operational { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
                  .warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
                  .critical { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
                  .metric { display: flex; justify-content: space-between; margin: 10px 0; }
                  h1 { color: #333; }
                  .timestamp { color: #666; font-size: 0.9em; }
              </style>
          </head>
          <body>
              <div class="container">
                  <h1>Pitchey Status - $ENVIRONMENT</h1>
                  <div class="timestamp">Last updated: <span id="lastUpdate"></span></div>
                  
                  <div class="status operational" id="overallStatus">
                      <strong>All Systems Operational</strong>
                  </div>
                  
                  <h3>Services</h3>
                  <div class="metric">
                      <span>Frontend</span>
                      <span class="status operational" id="frontendStatus">Operational</span>
                  </div>
                  <div class="metric">
                      <span>API</span>
                      <span class="status operational" id="apiStatus">Operational</span>
                  </div>
                  <div class="metric">
                      <span>Database</span>
                      <span class="status operational" id="dbStatus">Operational</span>
                  </div>
                  
                  <h3>Performance Metrics</h3>
                  <div class="metric">
                      <span>Response Time (P95)</span>
                      <span id="responseTime">-</span>
                  </div>
                  <div class="metric">
                      <span>Uptime (24h)</span>
                      <span id="uptime">-</span>
                  </div>
                  <div class="metric">
                      <span>Error Rate</span>
                      <span id="errorRate">-</span>
                  </div>
              </div>
              
              <script>
                  // Update timestamp
                  document.getElementById('lastUpdate').textContent = new Date().toISOString();
                  
                  // Fetch real status data (would be replaced with actual API calls)
                  async function updateStatus() {
                      try {
                          // This would fetch from your monitoring API
                          const response = await fetch('/api/status');
                          const data = await response.json();
                          
                          // Update UI with real data
                          // Implementation would depend on your monitoring API
                      } catch (error) {
                          console.error('Failed to fetch status:', error);
                      }
                  }
                  
                  // Update every 30 seconds
                  setInterval(updateStatus, 30000);
                  updateStatus();
              </script>
          </body>
          </html>
          EOF

      - name: Upload dashboard configuration
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-dashboard-${{ needs.monitoring-infrastructure.outputs.environment }}
          path: |
            monitoring-dashboard-*.json
            status-page-*.html
          retention-days: 90

  # Monitoring validation and notification
  monitoring-completion:
    name: Monitoring Setup Completion
    runs-on: ubuntu-latest
    needs: [monitoring-infrastructure, sentry-setup, uptime-monitoring, performance-monitoring, alert-setup, dashboard-setup]
    if: always()
    
    steps:
      - name: Validate monitoring setup
        id: validation
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          
          echo "âœ… Validating monitoring setup for $ENVIRONMENT"
          
          # Check which components were set up successfully
          SENTRY_STATUS="${{ needs.sentry-setup.result }}"
          UPTIME_STATUS="${{ needs.uptime-monitoring.result }}"
          PERFORMANCE_STATUS="${{ needs.performance-monitoring.result }}"
          ALERTS_STATUS="${{ needs.alert-setup.result }}"
          DASHBOARD_STATUS="${{ needs.dashboard-setup.result }}"
          
          echo "Component status:"
          echo "- Sentry: $SENTRY_STATUS"
          echo "- Uptime monitoring: $UPTIME_STATUS"
          echo "- Performance monitoring: $PERFORMANCE_STATUS"
          echo "- Alerts: $ALERTS_STATUS"
          echo "- Dashboard: $DASHBOARD_STATUS"
          
          # Determine overall status
          if [[ "$SENTRY_STATUS" == "success" && "$UPTIME_STATUS" == "success" && "$ALERTS_STATUS" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=Monitoring setup completed successfully" >> $GITHUB_OUTPUT
          else
            echo "status=partial" >> $GITHUB_OUTPUT
            echo "message=Monitoring setup completed with some issues" >> $GITHUB_OUTPUT
          fi

      - name: Create monitoring summary
        run: |
          ENVIRONMENT="${{ needs.monitoring-infrastructure.outputs.environment }}"
          
          cat > monitoring-summary.md << EOF
          # Monitoring Setup Summary - $ENVIRONMENT
          
          **Environment:** $ENVIRONMENT
          **Setup Date:** $(date -u)
          **Setup by:** ${{ github.actor }}
          **Status:** ${{ steps.validation.outputs.status }}
          
          ## Components Configured
          
          - âœ… **Sentry Error Tracking** - Real-time error monitoring and alerting
          - âœ… **Uptime Monitoring** - Service availability monitoring
          - âœ… **Performance Monitoring** - Web Vitals and response time tracking
          - âœ… **Alert Rules** - Automated alerting for critical issues
          - âœ… **Monitoring Dashboard** - Centralized monitoring view
          
          ## Alert Channels
          
          - ðŸ“§ Email notifications: Enabled
          - ðŸ’¬ Slack notifications: ${{ secrets.SLACK_WEBHOOK_URL && 'Enabled' || 'Disabled' }}
          - ðŸ“Ÿ PagerDuty (Production only): ${{ secrets.PAGERDUTY_ROUTING_KEY && needs.monitoring-infrastructure.outputs.environment == 'production' && 'Enabled' || 'Disabled' }}
          
          ## Next Steps
          
          1. Verify alert channels are working correctly
          2. Review and adjust alert thresholds if needed
          3. Set up additional monitoring as required
          4. Configure monitoring dashboard access
          
          ## Monitoring Endpoints
          
          - **API Health:** ${{ fromJSON(needs.monitoring-infrastructure.outputs.monitoring_endpoints).health_endpoint }}
          - **Frontend:** ${{ fromJSON(needs.monitoring-infrastructure.outputs.monitoring_endpoints).frontend_url }}
          - **Status Page:** Available in artifacts
          EOF

      - name: Final notification
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "${{ steps.validation.outputs.status == 'success' && 'âœ…' || 'âš ï¸' }} Monitoring setup ${{ steps.validation.outputs.status == 'success' && 'completed' || 'completed with issues' }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{ steps.validation.outputs.status == 'success' && 'âœ…' || 'âš ï¸' }} *Monitoring Setup Completed*\n\n*Environment:* ${{ needs.monitoring-infrastructure.outputs.environment }}\n*Status:* ${{ steps.validation.outputs.message }}\n*Setup by:* ${{ github.actor }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Configured:*\nâ€¢ Sentry error tracking\nâ€¢ Uptime monitoring\nâ€¢ Performance monitoring\nâ€¢ Alert rules\nâ€¢ Monitoring dashboard"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: env.SLACK_WEBHOOK_URL != ''

      - name: Upload monitoring summary
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-summary-${{ needs.monitoring-infrastructure.outputs.environment }}
          path: monitoring-summary.md
          retention-days: 365