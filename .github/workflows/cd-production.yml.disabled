name: CD - Production Deployment

on:
  # Manual trigger only for production deployments
  workflow_dispatch:
    inputs:
      version_tag:
        description: 'Version tag to deploy (e.g., v1.0.0 or commit SHA)'
        required: true
        type: string
      deployment_type:
        description: 'Type of deployment'
        required: true
        default: 'standard'
        type: choice
        options:
          - standard
          - hotfix
          - rollback
      rollback_version:
        description: 'Version to rollback to (only for rollback deployments)'
        required: false
        type: string
      skip_tests:
        description: 'Skip tests (only for hotfix/emergency deployments)'
        required: false
        default: false
        type: boolean
      maintenance_mode:
        description: 'Enable maintenance mode during deployment'
        required: false
        default: false
        type: boolean

  # Allow triggering from staging success (with approval)
  workflow_run:
    workflows: ["CD - Staging Deployment"]
    types: [completed]
    branches: [main]

concurrency:
  group: cd-production
  cancel-in-progress: false # Never cancel production deployments

env:
  NODE_VERSION: '20'
  DENO_VERSION: '2.x'
  PRODUCTION_URL: 'https://pitchey.pages.dev'
  PRODUCTION_API_URL: 'https://pitchey-production.cavelltheleaddev.workers.dev'

jobs:
  # Production deployment approval gate
  production-approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    environment:
      name: production-approval
      # This requires manual approval from designated team members
    outputs:
      approved: ${{ steps.approval.outputs.approved }}
      deployment_id: ${{ steps.deployment.outputs.deployment_id }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version_tag || github.sha }}

      - name: Validate deployment request
        id: validate
        run: |
          echo "ðŸ” Validating production deployment request..."
          
          VERSION_TAG="${{ github.event.inputs.version_tag || github.sha }}"
          DEPLOYMENT_TYPE="${{ github.event.inputs.deployment_type || 'standard' }}"
          
          echo "version_tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "deployment_type=$DEPLOYMENT_TYPE" >> $GITHUB_OUTPUT
          
          # Validate version exists
          if ! git rev-parse "$VERSION_TAG" >/dev/null 2>&1; then
            echo "âŒ Invalid version tag: $VERSION_TAG"
            exit 1
          fi
          
          # Additional validations for rollback
          if [ "$DEPLOYMENT_TYPE" = "rollback" ]; then
            ROLLBACK_VERSION="${{ github.event.inputs.rollback_version }}"
            if [ -z "$ROLLBACK_VERSION" ]; then
              echo "âŒ Rollback version is required for rollback deployments"
              exit 1
            fi
            if ! git rev-parse "$ROLLBACK_VERSION" >/dev/null 2>&1; then
              echo "âŒ Invalid rollback version: $ROLLBACK_VERSION"
              exit 1
            fi
          fi
          
          echo "âœ… Deployment request validated"

      - name: Create deployment record
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: '${{ steps.validate.outputs.version_tag }}',
              environment: 'production',
              description: 'Production deployment ${{ steps.validate.outputs.deployment_type }} - ${{ steps.validate.outputs.version_tag }}',
              auto_merge: false,
              required_contexts: []
            });
            
            core.setOutput('deployment_id', deployment.data.id);
            return deployment.data.id;

      - name: Request approval
        id: approval
        run: |
          echo "âœ‹ Production deployment requires manual approval"
          echo "approved=true" >> $GITHUB_OUTPUT
          
          # Log deployment details for approval review
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## ðŸš€ Production Deployment Request
          
          **Deployment Details:**
          - **Version:** `${{ steps.validate.outputs.version_tag }}`
          - **Type:** `${{ steps.validate.outputs.deployment_type }}`
          - **Requester:** ${{ github.actor }}
          - **Timestamp:** $(date -u)
          
          **Configuration:**
          - Skip Tests: ${{ github.event.inputs.skip_tests }}
          - Maintenance Mode: ${{ github.event.inputs.maintenance_mode }}
          - Rollback Version: ${{ github.event.inputs.rollback_version || 'N/A' }}
          
          **Pre-deployment Checklist:**
          - [ ] Code review completed
          - [ ] Staging deployment tested
          - [ ] Database migrations reviewed
          - [ ] Rollback plan confirmed
          - [ ] Team notified
          EOF

      - name: Notify approval request
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "ðŸš¨ Production deployment approval required",
              blocks: [
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: "ðŸš¨ *Production Deployment Approval Required*\n\n*Version:* `${{ steps.validate.outputs.version_tag }}`\n*Type:* ${{ steps.validate.outputs.deployment_type }}\n*Requester:* ${{ github.actor }}\n\nâš ï¸ Manual approval required to proceed."
                  }
                },
                {
                  type: "actions",
                  elements: [
                    {
                      type: "button",
                      text: {
                        type: "plain_text",
                        text: "View Details"
                      },
                      url: "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: env.SLACK_WEBHOOK_URL != ''

  # Pre-production validation
  pre-production-validation:
    name: Pre-production Validation
    runs-on: ubuntu-latest
    needs: production-approval
    if: needs.production-approval.outputs.approved == 'true'
    
    steps:
      - name: Checkout production code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version_tag || github.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: ${{ env.DENO_VERSION }}

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Run production tests
        if: github.event.inputs.skip_tests != 'true'
        working-directory: frontend
        run: |
          echo "ðŸ§ª Running production validation tests..."
          npm run test:ci
          npm run type-check
          npm run lint

      - name: Validate worker code
        if: github.event.inputs.skip_tests != 'true'
        run: |
          echo "ðŸ” Validating worker code..."
          deno check src/worker-platform-fixed.ts
          deno lint src/
          deno fmt --check src/

      - name: Security scan
        if: github.event.inputs.skip_tests != 'true'
        run: |
          echo "ðŸ›¡ï¸ Running security scan..."
          npm audit --audit-level=high --prefix frontend/
          
          # Additional security checks for production
          echo "Checking for secrets in code..."
          if grep -r "password\|secret\|key" src/ frontend/src/ --include="*.ts" --include="*.js" | grep -v "// SAFE:" | grep -v "placeholder"; then
            echo "âŒ Potential secrets found in code"
            exit 1
          fi

      - name: Build production artifacts
        working-directory: frontend
        env:
          VITE_API_URL: ${{ env.PRODUCTION_API_URL }}
          VITE_WS_URL: wss://pitchey-production.cavelltheleaddev.workers.dev
          VITE_ENVIRONMENT: production
          VITE_SENTRY_ENVIRONMENT: production
          NODE_ENV: production
        run: |
          echo "ðŸ—ï¸ Building production artifacts..."
          npm run build:prod

      - name: Upload production build
        uses: actions/upload-artifact@v4
        with:
          name: production-build
          path: |
            frontend/dist/
            wrangler.toml
            src/
          retention-days: 90 # Longer retention for production builds

  # Database migration (if needed)
  database-migration:
    name: Database Migration
    runs-on: ubuntu-latest
    needs: [production-approval, pre-production-validation]
    if: contains(github.event.head_commit.message, '[db-migration]') || github.event.inputs.deployment_type == 'standard'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version_tag || github.sha }}

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: ${{ env.DENO_VERSION }}

      - name: Backup database
        run: |
          echo "ðŸ’¾ Creating database backup before migration..."
          # This would typically connect to your database and create a backup
          echo "Database backup completed (placeholder)"

      - name: Run migrations
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        run: |
          echo "ðŸ—ƒï¸ Running database migrations..."
          # Add your actual migration command here
          echo "Database migrations completed (placeholder)"

      - name: Verify migration
        run: |
          echo "âœ… Verifying database migration..."
          # Add verification steps
          echo "Migration verification completed"

  # Enable maintenance mode (if requested)
  maintenance-mode:
    name: Enable Maintenance Mode
    runs-on: ubuntu-latest
    needs: [production-approval, pre-production-validation]
    if: github.event.inputs.maintenance_mode == 'true'
    
    steps:
      - name: Enable maintenance mode
        run: |
          echo "ðŸš§ Enabling maintenance mode..."
          # Implement maintenance mode activation
          # This could involve:
          # - Updating a KV store value
          # - Deploying a maintenance page
          # - Setting a feature flag
          
          curl -X POST "${{ env.PRODUCTION_API_URL }}/admin/maintenance" \
            -H "Authorization: Bearer ${{ secrets.ADMIN_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{"enabled": true, "message": "System maintenance in progress"}' || true
          
          echo "ðŸš§ Maintenance mode enabled"

      - name: Notify maintenance mode
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "ðŸš§ Production maintenance mode enabled",
              blocks: [
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: "ðŸš§ *Production Maintenance Mode Enabled*\n\nSystem is now in maintenance mode for deployment."
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: env.SLACK_WEBHOOK_URL != ''

  # Deploy to production
  production-deployment:
    name: Production Deployment
    runs-on: ubuntu-latest
    needs: [production-approval, pre-production-validation, database-migration, maintenance-mode]
    if: always() && needs.production-approval.outputs.approved == 'true' && (needs.pre-production-validation.result == 'success' || needs.pre-production-validation.result == 'skipped')
    environment:
      name: production
      url: ${{ env.PRODUCTION_URL }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version_tag || github.sha }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: production-build

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Wrangler
        run: npm install -g wrangler@latest

      - name: Create production wrangler config
        run: |
          # Create production-specific configuration
          cat > wrangler.production.toml << 'EOF'
          name = "pitchey-production"
          main = "src/worker-platform-fixed.ts"
          compatibility_date = "2024-11-01"
          compatibility_flags = ["nodejs_compat"]
          account_id = "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}"
          
          [vars]
          JWT_SECRET = "${{ secrets.PRODUCTION_JWT_SECRET }}"
          ENVIRONMENT = "production"
          
          # Production KV namespace
          [[kv_namespaces]]
          binding = "KV"
          id = "${{ secrets.PRODUCTION_KV_NAMESPACE_ID }}"
          
          # Production R2 bucket
          [[r2_buckets]]
          binding = "R2_BUCKET"
          bucket_name = "pitchey-uploads"
          
          # Durable Objects
          [[durable_objects.bindings]]
          name = "WEBSOCKET_ROOM"
          class_name = "WebSocketRoom"
          
          [[durable_objects.bindings]]
          name = "NOTIFICATION_ROOM"
          class_name = "NotificationRoom"
          
          # Production Hyperdrive
          [[hyperdrive]]
          binding = "HYPERDRIVE"
          id = "${{ secrets.PRODUCTION_HYPERDRIVE_ID }}"
          
          # Rate limiting for production
          [limits]
          cpu_ms = 50000
          EOF

      - name: Deploy Worker to production
        run: |
          echo "ðŸš€ Deploying worker to production..."
          wrangler deploy --config wrangler.production.toml
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Deploy Pages to production
        working-directory: frontend
        run: |
          echo "ðŸš€ Deploying frontend to production..."
          wrangler pages deploy dist \
            --project-name=pitchey \
            --branch=main \
            --compatibility-date=2024-11-01
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Update deployment metadata
        run: |
          echo "DEPLOYMENT_VERSION=${{ github.event.inputs.version_tag || github.sha }}" >> $GITHUB_ENV
          echo "DEPLOYMENT_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV
          echo "DEPLOYMENT_TYPE=${{ github.event.inputs.deployment_type || 'standard' }}" >> $GITHUB_ENV

  # Post-deployment validation
  production-validation:
    name: Production Validation
    runs-on: ubuntu-latest
    needs: production-deployment
    
    steps:
      - name: Wait for deployment propagation
        run: |
          echo "â³ Waiting for global deployment propagation..."
          sleep 60

      - name: Comprehensive health checks
        run: |
          echo "ðŸ¥ Running comprehensive production health checks..."
          
          # API health check
          API_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_API_URL }}/health")
          if [ "$API_HEALTH" -eq 200 ]; then
            echo "âœ… API health check passed"
          else
            echo "âŒ API health check failed (HTTP $API_HEALTH)"
            exit 1
          fi
          
          # Frontend health check
          FRONTEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}")
          if [ "$FRONTEND_HEALTH" -eq 200 ]; then
            echo "âœ… Frontend health check passed"
          else
            echo "âŒ Frontend health check failed (HTTP $FRONTEND_HEALTH)"
            exit 1
          fi
          
          # Database connectivity
          DB_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_API_URL }}/api/health/db")
          if [ "$DB_HEALTH" -eq 200 ]; then
            echo "âœ… Database health check passed"
          else
            echo "âš ï¸ Database health check warning (HTTP $DB_HEALTH)"
          fi

      - name: Critical path testing
        run: |
          echo "ðŸ§ª Running critical path tests..."
          
          # Test key user journeys
          curl -f "${{ env.PRODUCTION_API_URL }}/api/pitches?limit=1" || exit 1
          curl -f "${{ env.PRODUCTION_URL }}/portal" || exit 1
          
          echo "âœ… Critical path tests passed"

      - name: Performance validation
        run: |
          echo "âš¡ Validating production performance..."
          
          # Measure response times
          API_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.PRODUCTION_API_URL }}/api/health")
          FRONTEND_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.PRODUCTION_URL }}")
          
          # Convert to milliseconds
          API_MS=$(echo "$API_TIME * 1000" | bc -l | cut -d. -f1)
          FRONTEND_MS=$(echo "$FRONTEND_TIME * 1000" | bc -l | cut -d. -f1)
          
          echo "API response time: ${API_MS}ms"
          echo "Frontend response time: ${FRONTEND_MS}ms"
          
          if [ "$API_MS" -lt 2000 ] && [ "$FRONTEND_MS" -lt 3000 ]; then
            echo "âœ… Performance validation passed"
          else
            echo "âš ï¸ Performance validation warning - slower than expected"
          fi

  # Disable maintenance mode
  disable-maintenance:
    name: Disable Maintenance Mode
    runs-on: ubuntu-latest
    needs: [production-deployment, production-validation]
    if: always() && github.event.inputs.maintenance_mode == 'true' && (needs.production-validation.result == 'success' || needs.production-validation.result == 'skipped')
    
    steps:
      - name: Disable maintenance mode
        run: |
          echo "âœ… Disabling maintenance mode..."
          
          curl -X POST "${{ env.PRODUCTION_API_URL }}/admin/maintenance" \
            -H "Authorization: Bearer ${{ secrets.ADMIN_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{"enabled": false}' || true
          
          echo "âœ… Maintenance mode disabled"

      - name: Notify maintenance end
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "âœ… Production maintenance completed",
              blocks: [
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: "âœ… *Production Maintenance Completed*\n\nSystem is now live and accepting traffic."
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: env.SLACK_WEBHOOK_URL != ''

  # Final notifications and cleanup
  deployment-completion:
    name: Deployment Completion
    runs-on: ubuntu-latest
    needs: [production-approval, production-deployment, production-validation, disable-maintenance]
    if: always() && needs.production-approval.outputs.approved == 'true'
    
    steps:
      - name: Determine final status
        id: status
        run: |
          if [[ "${{ needs.production-deployment.result }}" == "success" && "${{ needs.production-validation.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=ðŸŽ‰" >> $GITHUB_OUTPUT
            echo "message=Production deployment successful" >> $GITHUB_OUTPUT
          elif [[ "${{ needs.production-deployment.result }}" == "failure" ]]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=ðŸ’¥" >> $GITHUB_OUTPUT
            echo "message=Production deployment failed" >> $GITHUB_OUTPUT
          else
            echo "status=partial" >> $GITHUB_OUTPUT
            echo "emoji=âš ï¸" >> $GITHUB_OUTPUT
            echo "message=Production deployment completed with warnings" >> $GITHUB_OUTPUT
          fi

      - name: Update deployment status
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ needs.production-approval.outputs.deployment_id }}',
              state: '${{ steps.status.outputs.status }}',
              environment_url: '${{ env.PRODUCTION_URL }}',
              description: '${{ steps.status.outputs.message }}'
            });

      - name: Final notification
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.message }}",
              blocks: [
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: "${{ steps.status.outputs.emoji }} *${{ steps.status.outputs.message }}*\n\n*Version:* `${{ github.event.inputs.version_tag || github.sha }}`\n*Type:* ${{ github.event.inputs.deployment_type || 'standard' }}\n*Environment:* Production\n*URL:* <${{ env.PRODUCTION_URL }}|${{ env.PRODUCTION_URL }}>\n*Deployed by:* ${{ github.actor }}"
                  },
                  accessory: {
                    type: "button",
                    text: {
                      type: "plain_text",
                      text: "View Live Site"
                    },
                    url: "${{ env.PRODUCTION_URL }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: env.SLACK_WEBHOOK_URL != ''

      - name: Create release tag
        if: steps.status.outputs.status == 'success' && github.event.inputs.deployment_type != 'rollback'
        uses: actions/github-script@v7
        with:
          script: |
            const tagName = 'prod-' + new Date().toISOString().slice(0,10) + '-' + context.sha.slice(0,7);
            
            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${tagName}`,
                sha: context.sha
              });
              
              console.log(`Created production release tag: ${tagName}`);
            } catch (error) {
              console.log('Tag creation failed:', error.message);
            }