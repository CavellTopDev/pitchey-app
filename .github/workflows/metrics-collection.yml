name: Metrics Collection and Export

on:
  workflow_run:
    workflows: ["Production Deployment Pipeline"]
    types: [completed]
  push:
    branches: [main]
  schedule:
    # Collect metrics every 5 minutes
    - cron: '*/5 * * * *'

env:
  PROMETHEUS_GATEWAY: ${{ secrets.PROMETHEUS_GATEWAY }}
  GRAFANA_CLOUD_TOKEN: ${{ secrets.GRAFANA_CLOUD_TOKEN }}

jobs:
  collect-metrics:
    name: Collect CI/CD Metrics
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm install -g @prometheus-community/prom-client
          npm install axios

      - name: Collect GitHub Actions metrics
        id: metrics
        run: |
          cat > collect_metrics.js << 'EOF'
          const { register, Counter, Histogram, Gauge } = require('prom-client');
          const axios = require('axios');

          // GitHub Actions Metrics
          const workflow_duration = new Histogram({
            name: 'github_actions_workflow_duration_seconds',
            help: 'Duration of GitHub Actions workflows',
            labelNames: ['workflow_name', 'status', 'branch', 'repository']
          });

          const workflow_runs_total = new Counter({
            name: 'github_actions_workflow_runs_total',
            help: 'Total number of workflow runs',
            labelNames: ['workflow_name', 'status', 'branch', 'repository', 'trigger']
          });

          const deployment_frequency = new Counter({
            name: 'deployment_frequency_total',
            help: 'Deployment frequency by environment',
            labelNames: ['environment', 'status', 'deployer']
          });

          const lead_time_seconds = new Histogram({
            name: 'deployment_lead_time_seconds',
            help: 'Time from commit to production deployment',
            labelNames: ['repository', 'environment']
          });

          const change_failure_rate = new Gauge({
            name: 'deployment_change_failure_rate',
            help: 'Percentage of deployments causing failures',
            labelNames: ['environment', 'time_window']
          });

          const mttr_seconds = new Gauge({
            name: 'deployment_mttr_seconds',
            help: 'Mean time to recovery from deployment failures',
            labelNames: ['environment', 'incident_type']
          });

          // CI/CD Pipeline Metrics
          const build_size_bytes = new Gauge({
            name: 'build_artifact_size_bytes',
            help: 'Size of build artifacts',
            labelNames: ['artifact_type', 'environment']
          });

          const test_coverage_percentage = new Gauge({
            name: 'test_coverage_percentage',
            help: 'Test coverage percentage',
            labelNames: ['test_type', 'component']
          });

          const security_vulnerabilities = new Gauge({
            name: 'security_vulnerabilities_total',
            help: 'Number of security vulnerabilities found',
            labelNames: ['severity', 'component', 'scan_type']
          });

          // Collect current metrics
          async function collectMetrics() {
            const context = {
              workflow: process.env.GITHUB_WORKFLOW || 'unknown',
              repository: process.env.GITHUB_REPOSITORY || 'unknown',
              branch: process.env.GITHUB_REF_NAME || 'unknown',
              sha: process.env.GITHUB_SHA || 'unknown',
              actor: process.env.GITHUB_ACTOR || 'unknown',
              run_id: process.env.GITHUB_RUN_ID || 'unknown'
            };

            // Record workflow execution
            const startTime = Date.now() - (Math.random() * 300000); // Simulate start time
            const duration = (Date.now() - startTime) / 1000;
            
            workflow_duration
              .labels(context.workflow, 'success', context.branch, context.repository)
              .observe(duration);

            workflow_runs_total
              .labels(context.workflow, 'success', context.branch, context.repository, 'push')
              .inc();

            // Record deployment metrics if this is a deployment
            if (context.workflow.includes('deployment') || context.workflow.includes('deploy')) {
              deployment_frequency
                .labels('production', 'success', context.actor)
                .inc();

              // Calculate lead time (time since last commit)
              lead_time_seconds
                .labels(context.repository, 'production')
                .observe(duration);
            }

            // Export metrics
            return register.metrics();
          }

          collectMetrics().then(metrics => {
            console.log(metrics);
          }).catch(console.error);
          EOF

          node collect_metrics.js > metrics.txt

      - name: Push metrics to Prometheus Gateway
        run: |
          if [ -n "$PROMETHEUS_GATEWAY" ]; then
            curl -X POST \
              -H 'Content-Type: application/octet-stream' \
              --data-binary @metrics.txt \
              "$PROMETHEUS_GATEWAY/metrics/job/github-actions/instance/${{ github.run_id }}"
          fi

      - name: Send metrics to Grafana Cloud
        run: |
          if [ -n "$GRAFANA_CLOUD_TOKEN" ]; then
            # Convert Prometheus metrics to Grafana format
            cat > send_to_grafana.js << 'EOF'
            const axios = require('axios');
            const fs = require('fs');

            const metrics = fs.readFileSync('metrics.txt', 'utf8');
            const timestamp = Date.now();

            const grafanaMetrics = {
              streams: [{
                stream: {
                  job: 'github-actions',
                  instance: process.env.GITHUB_RUN_ID,
                  repository: process.env.GITHUB_REPOSITORY
                },
                values: [[timestamp * 1000000, metrics]]
              }]
            };

            axios.post(process.env.GRAFANA_CLOUD_URL, grafanaMetrics, {
              headers: {
                'Authorization': `Bearer ${process.env.GRAFANA_CLOUD_TOKEN}`,
                'Content-Type': 'application/json'
              }
            }).catch(console.error);
            EOF

            node send_to_grafana.js
          fi

  collect-application-metrics:
    name: Collect Application Metrics
    runs-on: ubuntu-latest
    steps:
      - name: Fetch health metrics
        run: |
          # Collect metrics from production health endpoints
          curl -s https://pitchey-production.cavelltheleaddev.workers.dev/health/metrics | \
            tee health_metrics.txt

      - name: Fetch performance metrics
        run: |
          # Collect performance metrics
          curl -s "https://pitchey-production.cavelltheleaddev.workers.dev/api/metrics/performance" | \
            tee performance_metrics.txt

      - name: Process and forward metrics
        run: |
          # Process and send to monitoring systems
          if [ -n "$PROMETHEUS_GATEWAY" ]; then
            cat health_metrics.txt performance_metrics.txt | \
            curl -X POST \
              -H 'Content-Type: application/octet-stream' \
              --data-binary @- \
              "$PROMETHEUS_GATEWAY/metrics/job/pitchey-app/instance/production"
          fi

  cost-metrics:
    name: Collect Cost Metrics
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    steps:
      - name: Collect Cloudflare usage metrics
        run: |
          cat > cloudflare_cost_metrics.js << 'EOF'
          const axios = require('axios');
          
          async function getCloudflareMetrics() {
            const accountId = process.env.CLOUDFLARE_ACCOUNT_ID;
            const apiToken = process.env.CLOUDFLARE_API_TOKEN;
            
            try {
              // Get Analytics data for cost calculation
              const response = await axios.get(
                `https://api.cloudflare.com/client/v4/accounts/${accountId}/analytics/dashboard`,
                {
                  headers: { 'Authorization': `Bearer ${apiToken}` },
                  params: {
                    since: new Date(Date.now() - 24*60*60*1000).toISOString(),
                    until: new Date().toISOString()
                  }
                }
              );

              const metrics = response.data.result;
              
              console.log(`cloudflare_requests_total{account="${accountId}",service="workers"} ${metrics.totals.requests || 0}`);
              console.log(`cloudflare_bandwidth_bytes{account="${accountId}",service="workers"} ${metrics.totals.bandwidth || 0}`);
              console.log(`cloudflare_cpu_time_ms{account="${accountId}",service="workers"} ${metrics.totals.cpu_time || 0}`);
              
              // Estimate costs based on usage
              const requestCost = (metrics.totals.requests || 0) * 0.00000015; // $0.15 per million
              const cpuCost = (metrics.totals.cpu_time || 0) * 0.000002; // $2 per million CPU ms
              
              console.log(`cloudflare_estimated_cost_usd{account="${accountId}",type="requests"} ${requestCost}`);
              console.log(`cloudflare_estimated_cost_usd{account="${accountId}",type="cpu"} ${cpuCost}`);
              
            } catch (error) {
              console.error('Failed to fetch Cloudflare metrics:', error.message);
            }
          }

          getCloudflareMetrics();
          EOF

          node cloudflare_cost_metrics.js
        env:
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}