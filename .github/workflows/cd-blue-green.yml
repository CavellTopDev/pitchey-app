name: Blue-Green Deployment Pipeline

on:
  push:
    branches: [main]
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests (emergency deployment)'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deploy (bypass quality gates)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  DENO_VERSION: 'v2.1.2'
  DEPLOYMENT_TIMEOUT: 600
  HEALTH_CHECK_RETRIES: 10
  HEALTH_CHECK_INTERVAL: 30

concurrency:
  group: deploy-${{ github.event.inputs.environment || 'production' }}
  cancel-in-progress: false

jobs:
  # Pre-deployment validation
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event.inputs.skip_tests != 'true'
    
    outputs:
      deployment-id: ${{ steps.deployment.outputs.deployment_id }}
      environment: ${{ steps.env.outputs.environment }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine Environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi
      
      - name: Create Deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ steps.env.outputs.environment }}',
              description: 'Blue-Green Deployment',
              auto_merge: false,
              required_contexts: []
            });
            
            core.setOutput('deployment_id', deployment.data.id);
            return deployment.data.id;
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: |
          npm ci
          cd frontend && npm ci
      
      - name: Check Recent Deployments
        run: |
          echo "üîç Checking recent deployment status..."
          # Check if there have been recent failed deployments
          recent_failures=$(curl -s \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/deployments" \
            | jq '[.[] | select(.environment == "${{ steps.env.outputs.environment }}" and .created_at > (now - 3600))] | length')
          
          if [[ $recent_failures -gt 3 ]]; then
            echo "‚ùå Too many recent deployments. Aborting for safety."
            exit 1
          fi
          echo "‚úÖ Recent deployment check passed"
      
      - name: Run Critical Tests
        if: github.event.inputs.force_deploy != 'true'
        run: |
          echo "üß™ Running critical tests before deployment..."
          npm run test:ci
          cd frontend && npm run test:ci

  # Build and prepare deployment artifacts
  build-artifacts:
    name: Build Deployment Artifacts
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [pre-deployment-checks]
    if: always() && (needs.pre-deployment-checks.result == 'success' || needs.pre-deployment-checks.result == 'skipped')
    
    outputs:
      frontend-hash: ${{ steps.frontend.outputs.hash }}
      worker-hash: ${{ steps.worker.outputs.hash }}
      environment: ${{ needs.pre-deployment-checks.outputs.environment || 'production' }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: |
          npm ci
          cd frontend && npm ci
      
      - name: Build Frontend
        id: frontend
        run: |
          cd frontend
          npm run build:prod
          
          # Generate hash for cache busting
          frontend_hash=$(find dist -type f -exec sha256sum {} \; | sha256sum | cut -d' ' -f1 | head -c 8)
          echo "hash=$frontend_hash" >> $GITHUB_OUTPUT
          
          # Create versioned build
          tar -czf "frontend-${frontend_hash}.tar.gz" -C dist .
        env:
          VITE_API_URL: ${{ needs.build-artifacts.outputs.environment == 'production' && 'https://pitchey-api-prod.ndlovucavelle.workers.dev' || 'https://pitchey-api-staging.ndlovucavelle.workers.dev' }}
          VITE_WS_URL: ${{ needs.build-artifacts.outputs.environment == 'production' && 'wss://pitchey-api-prod.ndlovucavelle.workers.dev' || 'wss://pitchey-api-staging.ndlovucavelle.workers.dev' }}
          VITE_SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          VITE_ENVIRONMENT: ${{ needs.build-artifacts.outputs.environment }}
          NODE_ENV: production
      
      - name: Build Worker
        id: worker
        run: |
          npm run build:worker
          
          # Generate hash for worker build
          worker_hash=$(sha256sum dist/worker.js | cut -d' ' -f1 | head -c 8)
          echo "hash=$worker_hash" >> $GITHUB_OUTPUT
      
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: deployment-artifacts-${{ steps.frontend.outputs.hash }}
          path: |
            frontend/frontend-*.tar.gz
            dist/worker.js
          retention-days: 7
      
      - name: Generate Deployment Manifest
        run: |
          cat > deployment-manifest.json << EOF
          {
            "version": "${{ github.sha }}",
            "environment": "${{ needs.build-artifacts.outputs.environment }}",
            "frontend_hash": "${{ steps.frontend.outputs.hash }}",
            "worker_hash": "${{ steps.worker.outputs.hash }}",
            "deployed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "deployed_by": "${{ github.actor }}",
            "ref": "${{ github.ref }}"
          }
          EOF
      
      - name: Upload Manifest
        uses: actions/upload-artifact@v3
        with:
          name: deployment-manifest
          path: deployment-manifest.json

  # Deploy to staging (Green environment)
  deploy-staging:
    name: Deploy to Green Environment
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [build-artifacts]
    if: needs.build-artifacts.outputs.environment == 'staging' || (needs.build-artifacts.outputs.environment == 'production' && github.event_name != 'workflow_dispatch')
    
    environment:
      name: staging
      url: https://pitchey-staging.pages.dev
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Download Artifacts
        uses: actions/download-artifact@v3
        with:
          name: deployment-artifacts-${{ needs.build-artifacts.outputs.frontend-hash }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Deploy Worker (Green)
        run: |
          npm install -g wrangler
          
          # Deploy with green environment suffix
          wrangler deploy --env staging --name pitchey-worker-green
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      
      - name: Update Worker Secrets (Green)
        run: |
          echo "${{ secrets.NEON_DATABASE_URL_STAGING }}" | wrangler secret put DATABASE_URL --env staging --name pitchey-worker-green
          echo "${{ secrets.JWT_SECRET }}" | wrangler secret put JWT_SECRET --env staging --name pitchey-worker-green
          echo "${{ secrets.UPSTASH_REDIS_REST_URL_STAGING }}" | wrangler secret put UPSTASH_REDIS_REST_URL --env staging --name pitchey-worker-green
          echo "${{ secrets.UPSTASH_REDIS_REST_TOKEN_STAGING }}" | wrangler secret put UPSTASH_REDIS_REST_TOKEN --env staging --name pitchey-worker-green
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      
      - name: Extract and Deploy Frontend (Green)
        run: |
          # Extract frontend build
          tar -xzf frontend-${{ needs.build-artifacts.outputs.frontend-hash }}.tar.gz
          
          # Deploy to staging Pages environment
          wrangler pages deploy . --project-name=pitchey-staging --env=green
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      
      - name: Wait for Deployment
        run: |
          echo "‚è≥ Waiting for deployment to stabilize..."
          sleep ${{ env.HEALTH_CHECK_INTERVAL }}

  # Health check staging environment
  health-check-staging:
    name: Health Check Green Environment
    runs-on: ubuntu-latest
    needs: [deploy-staging, build-artifacts]
    if: always() && needs.deploy-staging.result == 'success'
    
    outputs:
      health-status: ${{ steps.health.outputs.status }}
    
    steps:
      - name: Comprehensive Health Check
        id: health
        run: |
          echo "üè• Running comprehensive health checks..."
          
          health_passed=true
          base_url="https://pitchey-worker-green.ndlovucavelle.workers.dev"
          
          # API Health Check
          for i in $(seq 1 ${{ env.HEALTH_CHECK_RETRIES }}); do
            echo "Attempt $i: Checking API health..."
            response=$(curl -s -w "%{http_code}" "$base_url/health" -o /tmp/health_response.json)
            
            if [[ "$response" == "200" ]]; then
              echo "‚úÖ API health check passed"
              break
            elif [[ "$i" == "${{ env.HEALTH_CHECK_RETRIES }}" ]]; then
              echo "‚ùå API health check failed after ${{ env.HEALTH_CHECK_RETRIES }} attempts"
              health_passed=false
            else
              echo "‚è≥ Waiting ${{ env.HEALTH_CHECK_INTERVAL }}s before retry..."
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            fi
          done
          
          # Database Connectivity Check
          echo "üîå Checking database connectivity..."
          db_response=$(curl -s "$base_url/health/database")
          if echo "$db_response" | grep -q "\"status\":\"healthy\""; then
            echo "‚úÖ Database connectivity check passed"
          else
            echo "‚ùå Database connectivity check failed"
            health_passed=false
          fi
          
          # Redis Connectivity Check
          echo "‚ö° Checking Redis connectivity..."
          redis_response=$(curl -s "$base_url/health/redis")
          if echo "$redis_response" | grep -q "\"status\":\"healthy\""; then
            echo "‚úÖ Redis connectivity check passed"
          else
            echo "‚ùå Redis connectivity check failed"
            health_passed=false
          fi
          
          # Frontend Accessibility Check
          echo "üåê Checking frontend accessibility..."
          frontend_response=$(curl -s -w "%{http_code}" "https://pitchey-staging.pages.dev" -o /dev/null)
          if [[ "$frontend_response" == "200" ]]; then
            echo "‚úÖ Frontend accessibility check passed"
          else
            echo "‚ùå Frontend accessibility check failed"
            health_passed=false
          fi
          
          if [[ "$health_passed" == "true" ]]; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "üéâ All health checks passed!"
          else
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            echo "üí• Health checks failed!"
            exit 1
          fi

  # Run smoke tests on staging
  smoke-tests-staging:
    name: Smoke Tests on Green Environment
    runs-on: ubuntu-latest
    needs: [health-check-staging, build-artifacts]
    if: needs.health-check-staging.outputs.health-status == 'healthy'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: |
          cd frontend
          npm ci
          npx playwright install --with-deps
      
      - name: Run Smoke Tests
        run: |
          cd frontend
          npm run test:e2e -- --grep="@smoke"
        env:
          BASE_URL: https://pitchey-staging.pages.dev
          API_URL: https://pitchey-worker-green.ndlovucavelle.workers.dev
          TEST_TIMEOUT: 30000
      
      - name: Upload Smoke Test Results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: smoke-test-results
          path: frontend/playwright-report/

  # Production deployment approval gate
  production-approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    needs: [smoke-tests-staging, build-artifacts]
    if: needs.build-artifacts.outputs.environment == 'production'
    environment:
      name: production-approval
    
    steps:
      - name: Manual Approval Required
        run: |
          echo "üö¶ Production deployment requires manual approval"
          echo "Staging tests completed successfully"
          echo "Ready to proceed with production deployment"

  # Deploy to production (Blue environment switch)
  deploy-production:
    name: Deploy to Production (Blue)
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [build-artifacts, smoke-tests-staging]
    if: |
      always() && 
      (needs.build-artifacts.outputs.environment == 'production') && 
      (needs.smoke-tests-staging.result == 'success' || github.event.inputs.force_deploy == 'true')
    
    environment:
      name: production
      url: https://pitchey-5o8-66n.pages.dev
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Download Artifacts
        uses: actions/download-artifact@v3
        with:
          name: deployment-artifacts-${{ needs.build-artifacts.outputs.frontend-hash }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      # Database migrations first
      - name: Run Production Migrations
        run: |
          npm ci
          npm run db:migrate:prod
        env:
          DATABASE_URL: ${{ secrets.NEON_DATABASE_URL }}
      
      # Deploy worker with blue-green switch
      - name: Deploy Worker (Blue-Green Switch)
        run: |
          npm install -g wrangler
          
          # Deploy new version
          wrangler deploy --env production --name pitchey-worker-blue
          
          # Quick health check of new worker
          sleep 30
          response=$(curl -s -w "%{http_code}" "https://pitchey-worker-blue.ndlovucavelle.workers.dev/health" -o /dev/null)
          
          if [[ "$response" != "200" ]]; then
            echo "‚ùå New worker health check failed, aborting switch"
            exit 1
          fi
          
          # Switch traffic to new worker (blue becomes active)
          echo "üîÑ Switching traffic to new worker..."
          
          # Update route to point to blue worker
          # This would require custom logic to update Cloudflare routes
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      
      - name: Update Production Secrets
        run: |
          echo "${{ secrets.NEON_DATABASE_URL }}" | wrangler secret put DATABASE_URL --env production
          echo "${{ secrets.JWT_SECRET }}" | wrangler secret put JWT_SECRET --env production
          echo "${{ secrets.UPSTASH_REDIS_REST_URL }}" | wrangler secret put UPSTASH_REDIS_REST_URL --env production
          echo "${{ secrets.UPSTASH_REDIS_REST_TOKEN }}" | wrangler secret put UPSTASH_REDIS_REST_TOKEN --env production
          echo "${{ secrets.SENTRY_DSN }}" | wrangler secret put SENTRY_DSN --env production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      
      - name: Deploy Frontend (Production)
        run: |
          # Extract frontend build
          tar -xzf frontend-${{ needs.build-artifacts.outputs.frontend-hash }}.tar.gz
          
          # Deploy to production Pages
          wrangler pages deploy . --project-name=pitchey-5o8-66n --env=production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      
      - name: Cache Warming
        run: |
          echo "üî• Warming up caches..."
          
          # Warm critical endpoints
          critical_endpoints=(
            "/"
            "/api/health"
            "/api/pitches"
            "/api/auth/session"
          )
          
          for endpoint in "${critical_endpoints[@]}"; do
            curl -s "https://pitchey-5o8-66n.pages.dev$endpoint" > /dev/null || true
            curl -s "https://pitchey-api-prod.ndlovucavelle.workers.dev$endpoint" > /dev/null || true
          done
          
          echo "‚úÖ Cache warming completed"

  # Production health verification
  health-check-production:
    name: Production Health Verification
    runs-on: ubuntu-latest
    needs: [deploy-production, build-artifacts]
    if: always() && needs.deploy-production.result == 'success'
    
    steps:
      - name: Comprehensive Production Health Check
        run: |
          echo "üè• Running production health verification..."
          
          health_passed=true
          api_url="https://pitchey-api-prod.ndlovucavelle.workers.dev"
          frontend_url="https://pitchey-5o8-66n.pages.dev"
          
          # Extended health check with monitoring
          for check_round in {1..3}; do
            echo "Health check round $check_round/3..."
            
            # API comprehensive check
            api_health=$(curl -s "$api_url/health" | jq -r '.status // "unhealthy"')
            if [[ "$api_health" != "healthy" ]]; then
              health_passed=false
              echo "‚ùå API health check failed in round $check_round"
            fi
            
            # Database check
            db_health=$(curl -s "$api_url/health/database" | jq -r '.status // "unhealthy"')
            if [[ "$db_health" != "healthy" ]]; then
              health_passed=false
              echo "‚ùå Database health check failed in round $check_round"
            fi
            
            # Redis check  
            redis_health=$(curl -s "$api_url/health/redis" | jq -r '.status // "unhealthy"')
            if [[ "$redis_health" != "healthy" ]]; then
              health_passed=false
              echo "‚ùå Redis health check failed in round $check_round"
            fi
            
            # Frontend check
            frontend_status=$(curl -s -w "%{http_code}" "$frontend_url" -o /dev/null)
            if [[ "$frontend_status" != "200" ]]; then
              health_passed=false
              echo "‚ùå Frontend check failed in round $check_round"
            fi
            
            if [[ "$health_passed" == "true" ]]; then
              echo "‚úÖ Round $check_round passed"
            fi
            
            sleep 30
          done
          
          if [[ "$health_passed" != "true" ]]; then
            echo "üí• Production health checks failed!"
            echo "üö® Triggering rollback procedures..."
            exit 1
          fi
          
          echo "üéâ Production health verification completed successfully!"
      
      - name: Performance Verification
        run: |
          echo "‚ö° Running performance verification..."
          
          # Check response times
          for i in {1..5}; do
            response_time=$(curl -s -w "%{time_total}" "https://pitchey-5o8-66n.pages.dev" -o /dev/null)
            echo "Response time test $i: ${response_time}s"
            
            # Alert if response time > 3 seconds
            if (( $(echo "$response_time > 3.0" | bc -l) )); then
              echo "‚ö†Ô∏è Slow response time detected: ${response_time}s"
            fi
          done
          
          echo "‚úÖ Performance verification completed"

  # Final deployment status update
  deployment-status:
    name: Update Deployment Status
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, health-check-production, build-artifacts]
    if: always() && needs.pre-deployment-checks.outputs.deployment-id
    
    steps:
      - name: Update Deployment Status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const deploymentId = '${{ needs.pre-deployment-checks.outputs.deployment-id }}';
            const environment = '${{ needs.build-artifacts.outputs.environment }}';
            const success = '${{ needs.health-check-production.result }}' === 'success';
            
            const environmentUrl = environment === 'production' 
              ? 'https://pitchey-5o8-66n.pages.dev'
              : 'https://pitchey-staging.pages.dev';
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deploymentId,
              state: success ? 'success' : 'failure',
              environment_url: environmentUrl,
              description: success 
                ? `Blue-Green deployment completed successfully to ${environment}`
                : `Deployment to ${environment} failed`,
            });
      
      - name: Send Deployment Notification
        run: |
          echo "üì¢ Sending deployment notifications..."
          
          if [[ "${{ needs.health-check-production.result }}" == "success" ]]; then
            status_emoji="üéâ"
            status_text="SUCCESS"
            color="28a745"
          else
            status_emoji="üí•"
            status_text="FAILED"
            color="dc3545"
          fi
          
          # Send Slack notification if configured
          if [[ -n "${{ secrets.SLACK_WEBHOOK }}" ]]; then
            curl -X POST "${{ secrets.SLACK_WEBHOOK }}" \
              -H 'Content-type: application/json' \
              -d "{
                \"text\": \"$status_emoji Blue-Green Deployment $status_text\",
                \"attachments\": [{
                  \"color\": \"$color\",
                  \"fields\": [
                    {\"title\": \"Environment\", \"value\": \"${{ needs.build-artifacts.outputs.environment }}\", \"short\": true},
                    {\"title\": \"Version\", \"value\": \"${{ github.sha }}\", \"short\": true},
                    {\"title\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"short\": true},
                    {\"title\": \"Status\", \"value\": \"$status_text\", \"short\": true}
                  ],
                  \"actions\": [{
                    \"type\": \"button\",
                    \"text\": \"View Site\",
                    \"url\": \"${{ needs.build-artifacts.outputs.environment == 'production' && 'https://pitchey-5o8-66n.pages.dev' || 'https://pitchey-staging.pages.dev' }}\"
                  }]
                }]
              }"
          fi
      
      - name: Create Sentry Release
        if: needs.health-check-production.result == 'success'
        run: |
          if [[ -n "${{ secrets.SENTRY_AUTH_TOKEN }}" ]]; then
            npm install -g @sentry/cli
            export SENTRY_RELEASE="${{ github.sha }}"
            
            sentry-cli releases new $SENTRY_RELEASE
            sentry-cli releases set-commits $SENTRY_RELEASE --auto
            sentry-cli releases finalize $SENTRY_RELEASE
            sentry-cli releases deploys $SENTRY_RELEASE new -e ${{ needs.build-artifacts.outputs.environment }}
          fi
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}