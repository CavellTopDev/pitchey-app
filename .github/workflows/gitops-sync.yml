name: GitOps Sync Pipeline

on:
  push:
    branches: [main, staging, develop]
    paths:
      - 'deployments/**'
      - 'infrastructure/**'
      - '.github/workflows/gitops-sync.yml'
  schedule:
    # Drift detection every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for sync'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      force_sync:
        description: 'Force sync even if no changes detected'
        required: false
        default: false
        type: boolean
      dry_run:
        description: 'Perform dry run without applying changes'
        required: false
        default: false
        type: boolean

env:
  GITOPS_VERSION: 'v1.0.0'
  MANIFEST_PATH: 'deployments'
  STATE_BUCKET: 'pitchey-gitops-state'

jobs:
  # Detect configuration drift
  drift-detection:
    runs-on: ubuntu-latest
    outputs:
      has-drift: ${{ steps.detect-drift.outputs.has-drift }}
      drift-summary: ${{ steps.detect-drift.outputs.drift-summary }}
      environments-changed: ${{ steps.detect-changes.outputs.environments-changed }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Install GitOps tools
        run: |
          # Install yq for YAML processing
          wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq
          
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq curl
      
      - name: Detect configuration changes
        id: detect-changes
        run: |
          echo "ðŸ” Detecting configuration changes..."
          
          # Detect which environments have manifest changes
          CHANGED_ENVS=""
          
          if git diff --name-only HEAD~1 HEAD | grep -q "deployments/production/"; then
            CHANGED_ENVS="$CHANGED_ENVS production"
          fi
          
          if git diff --name-only HEAD~1 HEAD | grep -q "deployments/staging/"; then
            CHANGED_ENVS="$CHANGED_ENVS staging"
          fi
          
          if git diff --name-only HEAD~1 HEAD | grep -q "deployments/development/"; then
            CHANGED_ENVS="$CHANGED_ENVS development"
          fi
          
          # Force sync if manually triggered
          if [ "${{ inputs.force_sync }}" == "true" ]; then
            CHANGED_ENVS="${{ inputs.environment }}"
          fi
          
          echo "environments-changed=$CHANGED_ENVS" >> $GITHUB_OUTPUT
          echo "Changed environments: $CHANGED_ENVS"
      
      - name: Fetch current state
        id: fetch-state
        run: |
          echo "ðŸ“¥ Fetching current deployment state..."
          
          # Create state directory
          mkdir -p .gitops-state
          
          # Fetch current Cloudflare Worker state
          curl -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/workers/scripts" \
            | jq '.result' > .gitops-state/current-workers.json
          
          # Fetch current Pages deployments
          curl -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects" \
            | jq '.result' > .gitops-state/current-pages.json
          
          # Fetch DNS records
          if [ -n "${{ secrets.CLOUDFLARE_ZONE_ID }}" ]; then
            curl -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records" \
              | jq '.result' > .gitops-state/current-dns.json
          fi
          
          echo "âœ… Current state fetched"
      
      - name: Detect drift
        id: detect-drift
        run: |
          echo "ðŸ”„ Analyzing configuration drift..."
          
          HAS_DRIFT="false"
          DRIFT_SUMMARY=""
          
          # Check each environment for drift
          for env in production staging development; do
            if [ -f "deployments/$env/desired-state.yml" ]; then
              echo "Checking $env environment..."
              
              # Compare desired vs actual worker configuration
              DESIRED_WORKER=$(yq eval '.worker.name' deployments/$env/desired-state.yml)
              DESIRED_ENV_VARS=$(yq eval '.worker.env_vars // {} | keys | join(",")' deployments/$env/desired-state.yml)
              
              # Check if worker exists in current state
              ACTUAL_WORKER=$(jq -r '.[] | select(.id == "'$DESIRED_WORKER'") | .id' .gitops-state/current-workers.json)
              
              if [ "$ACTUAL_WORKER" != "$DESIRED_WORKER" ]; then
                HAS_DRIFT="true"
                DRIFT_SUMMARY="$DRIFT_SUMMARY\n- $env: Worker '$DESIRED_WORKER' not found"
              fi
              
              # Check Pages deployment
              DESIRED_PAGES=$(yq eval '.pages.project_name' deployments/$env/desired-state.yml)
              ACTUAL_PAGES=$(jq -r '.[] | select(.name == "'$DESIRED_PAGES'") | .name' .gitops-state/current-pages.json)
              
              if [ "$ACTUAL_PAGES" != "$DESIRED_PAGES" ]; then
                HAS_DRIFT="true"
                DRIFT_SUMMARY="$DRIFT_SUMMARY\n- $env: Pages project '$DESIRED_PAGES' configuration drift"
              fi
            fi
          done
          
          echo "has-drift=$HAS_DRIFT" >> $GITHUB_OUTPUT
          echo "drift-summary=$DRIFT_SUMMARY" >> $GITHUB_OUTPUT
          
          if [ "$HAS_DRIFT" == "true" ]; then
            echo "âš ï¸ Configuration drift detected!"
            echo -e "$DRIFT_SUMMARY"
          else
            echo "âœ… No drift detected"
          fi
      
      - name: Upload drift report
        if: steps.detect-drift.outputs.has-drift == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: drift-report-${{ github.sha }}
          path: .gitops-state/
          retention-days: 30

  # Validate manifests
  validate-manifests:
    needs: drift-detection
    runs-on: ubuntu-latest
    if: needs.drift-detection.outputs.environments-changed != ''
    strategy:
      matrix:
        environment: ${{ fromJson(format('["{0}"]', needs.drift-detection.outputs.environments-changed)) }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Install validation tools
        run: |
          # Install schema validation tools
          pip install yamllint jsonschema
          
          # Install yq for YAML processing
          wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq
      
      - name: Validate YAML syntax
        run: |
          echo "ðŸ” Validating YAML syntax for ${{ matrix.environment }}..."
          
          if [ -d "deployments/${{ matrix.environment }}" ]; then
            yamllint deployments/${{ matrix.environment }}/*.yml
            echo "âœ… YAML syntax validation passed"
          else
            echo "âš ï¸ No manifests found for ${{ matrix.environment }}"
          fi
      
      - name: Validate manifest schema
        run: |
          echo "ðŸ” Validating manifest schema for ${{ matrix.environment }}..."
          
          # Create JSON schema for validation
          cat > manifest-schema.json << 'EOF'
          {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "type": "object",
            "required": ["apiVersion", "kind", "metadata", "spec"],
            "properties": {
              "apiVersion": {
                "type": "string",
                "pattern": "^gitops/v1$"
              },
              "kind": {
                "type": "string",
                "enum": ["Application", "Environment"]
              },
              "metadata": {
                "type": "object",
                "required": ["name", "environment"],
                "properties": {
                  "name": {"type": "string"},
                  "environment": {"type": "string"},
                  "labels": {"type": "object"},
                  "annotations": {"type": "object"}
                }
              },
              "spec": {
                "type": "object",
                "required": ["source", "destination"],
                "properties": {
                  "source": {
                    "type": "object",
                    "required": ["repoURL", "path"],
                    "properties": {
                      "repoURL": {"type": "string"},
                      "path": {"type": "string"},
                      "targetRevision": {"type": "string"}
                    }
                  },
                  "destination": {
                    "type": "object",
                    "required": ["platform"],
                    "properties": {
                      "platform": {"type": "string", "enum": ["cloudflare"]},
                      "account": {"type": "string"}
                    }
                  }
                }
              }
            }
          }
          EOF
          
          # Validate each manifest file
          for manifest in deployments/${{ matrix.environment }}/*.yml; do
            if [ -f "$manifest" ]; then
              echo "Validating $manifest..."
              
              # Convert YAML to JSON and validate
              yq eval -o=json "$manifest" | jsonschema -i /dev/stdin manifest-schema.json
              echo "âœ… $manifest validated successfully"
            fi
          done
      
      - name: Check resource constraints
        run: |
          echo "ðŸ” Validating resource constraints for ${{ matrix.environment }}..."
          
          # Check if resource limits are within bounds
          for manifest in deployments/${{ matrix.environment }}/*.yml; do
            if [ -f "$manifest" ]; then
              # Check memory limits for Workers
              MEMORY_LIMIT=$(yq eval '.spec.worker.resources.memory // "128MB"' "$manifest")
              echo "Worker memory limit: $MEMORY_LIMIT"
              
              # Check CPU limits
              CPU_TIME=$(yq eval '.spec.worker.resources.cpuTime // "50ms"' "$manifest")
              echo "CPU time limit: $CPU_TIME"
              
              # Validate environment-specific constraints
              if [ "${{ matrix.environment }}" == "production" ]; then
                # Production should have higher limits
                if [[ "$MEMORY_LIMIT" == "128MB" ]]; then
                  echo "âš ï¸ Production environment should have higher memory limits"
                fi
              fi
            fi
          done
          
          echo "âœ… Resource constraints validated"

  # Apply GitOps changes
  gitops-sync:
    needs: [drift-detection, validate-manifests]
    runs-on: ubuntu-latest
    if: |
      always() && 
      (needs.drift-detection.outputs.has-drift == 'true' || 
       needs.drift-detection.outputs.environments-changed != '' ||
       inputs.force_sync)
    strategy:
      matrix:
        environment: ${{ fromJson(format('["{0}"]', needs.drift-detection.outputs.environments-changed || inputs.environment)) }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Install GitOps tools
        run: |
          # Install yq and jq
          wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq
          sudo apt-get update && sudo apt-get install -y jq curl
      
      - name: Parse desired state
        id: parse-state
        run: |
          echo "ðŸ“‹ Parsing desired state for ${{ matrix.environment }}..."
          
          MANIFEST_FILE="deployments/${{ matrix.environment }}/desired-state.yml"
          
          if [ ! -f "$MANIFEST_FILE" ]; then
            echo "âŒ Manifest file not found: $MANIFEST_FILE"
            exit 1
          fi
          
          # Extract configuration values
          WORKER_NAME=$(yq eval '.spec.worker.name' "$MANIFEST_FILE")
          WORKER_SCRIPT=$(yq eval '.spec.worker.script' "$MANIFEST_FILE")
          PAGES_PROJECT=$(yq eval '.spec.pages.project' "$MANIFEST_FILE")
          DOMAIN=$(yq eval '.spec.domain // ""' "$MANIFEST_FILE")
          
          echo "worker-name=$WORKER_NAME" >> $GITHUB_OUTPUT
          echo "worker-script=$WORKER_SCRIPT" >> $GITHUB_OUTPUT
          echo "pages-project=$PAGES_PROJECT" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          
          echo "Parsed configuration:"
          echo "- Worker: $WORKER_NAME"
          echo "- Script: $WORKER_SCRIPT"
          echo "- Pages: $PAGES_PROJECT"
          echo "- Domain: $DOMAIN"
      
      - name: Dry run check
        if: inputs.dry_run
        run: |
          echo "ðŸ§ª DRY RUN MODE - No changes will be applied"
          echo "Would apply the following changes for ${{ matrix.environment }}:"
          echo "- Deploy worker: ${{ steps.parse-state.outputs.worker-name }}"
          echo "- Deploy pages project: ${{ steps.parse-state.outputs.pages-project }}"
          echo "- Configure domain: ${{ steps.parse-state.outputs.domain }}"
          exit 0
      
      - name: Apply worker configuration
        if: ${{ !inputs.dry_run }}
        run: |
          echo "ðŸš€ Applying worker configuration for ${{ matrix.environment }}..."
          
          WORKER_NAME="${{ steps.parse-state.outputs.worker-name }}"
          WORKER_SCRIPT="${{ steps.parse-state.outputs.worker-script }}"
          
          # Create environment-specific wrangler config
          cat > "wrangler-${{ matrix.environment }}.toml" << EOF
          name = "$WORKER_NAME"
          main = "$WORKER_SCRIPT"
          compatibility_date = "2024-11-01"
          compatibility_flags = ["nodejs_compat"]
          account_id = "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}"
          
          [vars]
          ENVIRONMENT = "${{ matrix.environment }}"
          FRONTEND_URL = "https://pitchey.pages.dev"
          
          [[kv_namespaces]]
          binding = "KV"
          id = "${{ secrets.CLOUDFLARE_KV_ID }}"
          
          [[r2_buckets]]
          binding = "R2_BUCKET"
          bucket_name = "pitchey-uploads"
          
          [[durable_objects.bindings]]
          name = "WEBSOCKET_ROOM"
          class_name = "WebSocketRoom"
          
          [[durable_objects.bindings]]
          name = "NOTIFICATION_ROOM"
          class_name = "NotificationRoom"
          EOF
          
          # Deploy worker using the environment-specific config
          npx wrangler@latest deploy --config "wrangler-${{ matrix.environment }}.toml" --env ${{ matrix.environment }}
          
          echo "âœ… Worker deployed successfully"
      
      - name: Apply pages configuration
        if: ${{ !inputs.dry_run }}
        run: |
          echo "ðŸ“„ Applying pages configuration for ${{ matrix.environment }}..."
          
          PAGES_PROJECT="${{ steps.parse-state.outputs.pages-project }}"
          
          # Check if pages project exists
          EXISTING_PROJECT=$(curl -s -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects" | \
            jq -r '.result[] | select(.name == "'$PAGES_PROJECT'") | .name')
          
          if [ "$EXISTING_PROJECT" == "$PAGES_PROJECT" ]; then
            echo "âœ… Pages project '$PAGES_PROJECT' already exists"
          else
            echo "Creating new pages project: $PAGES_PROJECT"
            
            # Create pages project
            curl -X POST "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects" \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              --data '{
                "name": "'$PAGES_PROJECT'",
                "production_branch": "main",
                "build_config": {
                  "build_command": "npm run build",
                  "destination_dir": "dist",
                  "root_dir": "frontend"
                }
              }'
            
            echo "âœ… Pages project created"
          fi
      
      - name: Apply domain configuration
        if: ${{ !inputs.dry_run && steps.parse-state.outputs.domain != '' }}
        run: |
          echo "ðŸŒ Applying domain configuration for ${{ matrix.environment }}..."
          
          DOMAIN="${{ steps.parse-state.outputs.domain }}"
          
          # Configure custom domain for the environment
          if [ "${{ matrix.environment }}" == "production" ]; then
            # Production domain configuration
            curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records" \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              --data '{
                "type": "CNAME",
                "name": "'$DOMAIN'",
                "content": "pitchey.pages.dev",
                "ttl": 1
              }' || echo "DNS record may already exist"
          fi
          
          echo "âœ… Domain configuration applied"
      
      - name: Verify deployment
        if: ${{ !inputs.dry_run }}
        run: |
          echo "ðŸ” Verifying deployment for ${{ matrix.environment }}..."
          
          WORKER_NAME="${{ steps.parse-state.outputs.worker-name }}"
          
          # Test worker endpoint
          for i in {1..10}; do
            if curl -sf "https://$WORKER_NAME.cavelltheleaddev.workers.dev/api/health"; then
              echo "âœ… Worker verification successful"
              break
            fi
            echo "â³ Worker verification attempt $i..."
            sleep 10
          done
          
          # Test pages deployment
          PAGES_PROJECT="${{ steps.parse-state.outputs.pages-project }}"
          
          if [ "$PAGES_PROJECT" == "pitchey" ]; then
            for i in {1..10}; do
              if curl -sf "https://pitchey.pages.dev"; then
                echo "âœ… Pages verification successful"
                break
              fi
              echo "â³ Pages verification attempt $i..."
              sleep 10
            done
          fi
      
      - name: Update deployment state
        if: ${{ !inputs.dry_run }}
        run: |
          echo "ðŸ’¾ Updating deployment state..."
          
          # Create deployment record
          cat > "deployment-state-${{ matrix.environment }}.json" << EOF
          {
            "timestamp": "$(date -u --iso-8601=seconds)",
            "environment": "${{ matrix.environment }}",
            "commit": "${{ github.sha }}",
            "worker": {
              "name": "${{ steps.parse-state.outputs.worker-name }}",
              "script": "${{ steps.parse-state.outputs.worker-script }}"
            },
            "pages": {
              "project": "${{ steps.parse-state.outputs.pages-project }}"
            },
            "domain": "${{ steps.parse-state.outputs.domain }}",
            "status": "deployed"
          }
          EOF
          
          echo "âœ… Deployment state updated"
      
      - name: Upload deployment state
        if: ${{ !inputs.dry_run }}
        uses: actions/upload-artifact@v4
        with:
          name: deployment-state-${{ matrix.environment }}-${{ github.sha }}
          path: deployment-state-${{ matrix.environment }}.json
          retention-days: 90

  # Reconciliation summary
  reconciliation-summary:
    needs: [drift-detection, gitops-sync]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Generate reconciliation report
        run: |
          echo "ðŸ“Š GitOps Reconciliation Summary"
          echo "================================"
          echo "Timestamp: $(date -u)"
          echo "Trigger: ${{ github.event_name }}"
          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "Drift Detection Results:"
          echo "- Has drift: ${{ needs.drift-detection.outputs.has-drift }}"
          echo "- Environments changed: ${{ needs.drift-detection.outputs.environments-changed }}"
          echo ""
          echo "Sync Results:"
          echo "- GitOps sync: ${{ needs.gitops-sync.result }}"
          echo ""
          
          if [ "${{ needs.drift-detection.outputs.has-drift }}" == "true" ]; then
            echo "Drift Summary:"
            echo -e "${{ needs.drift-detection.outputs.drift-summary }}"
          fi
          
          # Create reconciliation artifact
          cat > reconciliation-report.json << EOF
          {
            "timestamp": "$(date -u --iso-8601=seconds)",
            "commit": "${{ github.sha }}",
            "trigger": "${{ github.event_name }}",
            "driftDetection": {
              "hasDrift": "${{ needs.drift-detection.outputs.has-drift }}",
              "environmentsChanged": "${{ needs.drift-detection.outputs.environments-changed }}",
              "summary": "${{ needs.drift-detection.outputs.drift-summary }}"
            },
            "syncResults": {
              "gitopsSync": "${{ needs.gitops-sync.result }}"
            }
          }
          EOF
      
      - name: Upload reconciliation report
        uses: actions/upload-artifact@v4
        with:
          name: reconciliation-report-${{ github.sha }}
          path: reconciliation-report.json
          retention-days: 90
      
      - name: Notify on drift
        if: needs.drift-detection.outputs.has-drift == 'true'
        run: |
          echo "ðŸš¨ Configuration drift detected and reconciled"
          echo "Review the reconciliation report for details"
          
          # In production, send notifications
          # curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
          #   -H 'Content-type: application/json' \
          #   --data '{"text":"âš ï¸ GitOps drift detected and reconciled in Pitchey deployment"}'