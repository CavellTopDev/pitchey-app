name: CD - Staging Deployment

on:
  push:
    branches: [main]
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'

  # Allow manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

concurrency:
  group: cd-staging
  cancel-in-progress: false # Don't cancel staging deployments

env:
  NODE_VERSION: '20'
  DENO_VERSION: '2.x'
  STAGING_URL: 'https://pitchey-staging.pages.dev'
  STAGING_API_URL: 'https://pitchey-staging.cavelltheleaddev.workers.dev'

jobs:
  # Pre-deployment validation
  pre-deploy-validation:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      version: ${{ steps.version.outputs.version }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate version
        id: version
        run: |
          VERSION="$(git rev-parse --short HEAD)-$(date +%Y%m%d-%H%M%S)"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

      - name: Check if deployment should proceed
        id: check
        run: |
          if [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "ðŸš€ Force deployment requested"
          else
            # Check for specific commit patterns that should skip deployment
            COMMIT_MSG=$(git log -1 --pretty=format:'%s')
            if echo "$COMMIT_MSG" | grep -E '\[skip-deploy\]|\[no-deploy\]'; then
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "â­ï¸ Deployment skipped due to commit message: $COMMIT_MSG"
            else
              echo "should_deploy=true" >> $GITHUB_OUTPUT
              echo "âœ… Deployment should proceed"
            fi
          fi

      - name: Notify deployment start
        if: steps.check.outputs.should_deploy == 'true'
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "ðŸš€ Starting staging deployment",
              blocks: [
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: "ðŸš€ *Starting Staging Deployment*\n\n*Version:* `${{ steps.version.outputs.version }}`\n*Commit:* <https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>\n*Author:* ${{ github.actor }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: env.SLACK_WEBHOOK_URL != ''

  # Build and test before deployment
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    needs: pre-deploy-validation
    if: needs.pre-deploy-validation.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: ${{ env.DENO_VERSION }}

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci

      - name: Run tests
        working-directory: frontend
        run: |
          npm run test:ci
          npm run type-check
          npm run lint

      - name: Test worker code
        run: |
          deno check src/worker-platform-fixed.ts
          deno lint src/
          deno fmt --check src/

      - name: Build frontend for staging
        working-directory: frontend
        env:
          VITE_API_URL: ${{ env.STAGING_API_URL }}
          VITE_WS_URL: wss://pitchey-staging.cavelltheleaddev.workers.dev
          VITE_ENVIRONMENT: staging
          VITE_SENTRY_ENVIRONMENT: staging
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: staging-build
          path: |
            frontend/dist/
            wrangler.toml
            src/
          retention-days: 30

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [pre-deploy-validation, build-and-test]
    if: needs.pre-deploy-validation.outputs.should_deploy == 'true'
    environment:
      name: staging
      url: ${{ env.STAGING_URL }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: staging-build

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Wrangler
        run: npm install -g wrangler@latest

      - name: Create staging wrangler config
        run: |
          # Create staging-specific configuration
          cat > wrangler.staging.toml << 'EOF'
          name = "pitchey-staging"
          main = "src/worker-platform-fixed.ts"
          compatibility_date = "2024-11-01"
          compatibility_flags = ["nodejs_compat"]
          account_id = "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}"
          
          [vars]
          JWT_SECRET = "${{ secrets.STAGING_JWT_SECRET }}"
          ENVIRONMENT = "staging"
          
          # Staging KV namespace
          [[kv_namespaces]]
          binding = "KV"
          id = "${{ secrets.STAGING_KV_NAMESPACE_ID }}"
          
          # Staging R2 bucket
          [[r2_buckets]]
          binding = "R2_BUCKET"
          bucket_name = "pitchey-uploads-staging"
          
          # Durable Objects
          [[durable_objects.bindings]]
          name = "WEBSOCKET_ROOM"
          class_name = "WebSocketRoom"
          
          [[durable_objects.bindings]]
          name = "NOTIFICATION_ROOM"
          class_name = "NotificationRoom"
          
          # Staging Hyperdrive (if enabled)
          [[hyperdrive]]
          binding = "HYPERDRIVE"
          id = "${{ secrets.STAGING_HYPERDRIVE_ID }}"
          EOF

      - name: Deploy Worker to staging
        run: |
          wrangler deploy --config wrangler.staging.toml --env staging
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Deploy Pages to staging
        working-directory: frontend
        run: |
          wrangler pages deploy dist \
            --project-name=pitchey-staging \
            --branch=main \
            --compatibility-date=2024-11-01
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Update deployment status
        run: |
          echo "DEPLOYMENT_VERSION=${{ needs.pre-deploy-validation.outputs.version }}" >> $GITHUB_ENV
          echo "DEPLOYMENT_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV

      - name: Create deployment record
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'staging',
              description: 'Staging deployment v${{ needs.pre-deploy-validation.outputs.version }}',
              auto_merge: false,
              required_contexts: []
            });

  # Post-deployment testing
  staging-smoke-tests:
    name: Staging Smoke Tests
    runs-on: ubuntu-latest
    needs: [pre-deploy-validation, deploy-staging]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for deployment propagation
        run: sleep 30

      - name: Health check
        run: |
          echo "ðŸ¥ Running health checks..."
          
          # Check API health
          API_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.STAGING_API_URL }}/health")
          if [ "$API_HEALTH" -eq 200 ]; then
            echo "âœ… API health check passed"
          else
            echo "âŒ API health check failed (HTTP $API_HEALTH)"
            exit 1
          fi
          
          # Check frontend
          FRONTEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.STAGING_URL }}")
          if [ "$FRONTEND_HEALTH" -eq 200 ]; then
            echo "âœ… Frontend health check passed"
          else
            echo "âŒ Frontend health check failed (HTTP $FRONTEND_HEALTH)"
            exit 1
          fi

      - name: API smoke tests
        run: |
          echo "ðŸ§ª Running API smoke tests..."
          
          # Test basic endpoints
          curl -f "${{ env.STAGING_API_URL }}/api/health" || exit 1
          curl -f "${{ env.STAGING_API_URL }}/api/pitches" || exit 1
          
          echo "âœ… API smoke tests passed"

      - name: Frontend smoke tests
        run: |
          echo "ðŸ§ª Running frontend smoke tests..."
          
          # Check that key resources load
          curl -f "${{ env.STAGING_URL }}" | grep -q "Pitchey" || exit 1
          
          echo "âœ… Frontend smoke tests passed"

      - name: Performance check
        run: |
          echo "âš¡ Checking performance..."
          
          # Basic performance check
          RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.STAGING_URL }}")
          
          # Convert to milliseconds and check if under 3 seconds
          RESPONSE_MS=$(echo "$RESPONSE_TIME * 1000" | bc -l | cut -d. -f1)
          
          if [ "$RESPONSE_MS" -lt 3000 ]; then
            echo "âœ… Performance check passed ($RESPONSE_MS ms)"
          else
            echo "âš ï¸ Performance check warning: ${RESPONSE_MS}ms (>3s)"
          fi

  # Notification and cleanup
  post-deployment:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [pre-deploy-validation, deploy-staging, staging-smoke-tests]
    if: always() && needs.pre-deploy-validation.outputs.should_deploy == 'true'
    
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [[ "${{ needs.deploy-staging.result }}" == "success" && "${{ needs.staging-smoke-tests.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=âœ…" >> $GITHUB_OUTPUT
            echo "message=Staging deployment successful" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=âŒ" >> $GITHUB_OUTPUT
            echo "message=Staging deployment failed" >> $GITHUB_OUTPUT
          fi

      - name: Notify deployment result
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.message }}",
              blocks: [
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: "${{ steps.status.outputs.emoji }} *${{ steps.status.outputs.message }}*\n\n*Version:* `${{ needs.pre-deploy-validation.outputs.version }}`\n*Environment:* Staging\n*URL:* <${{ env.STAGING_URL }}|${{ env.STAGING_URL }}>\n*API:* <${{ env.STAGING_API_URL }}|${{ env.STAGING_API_URL }}>"
                  },
                  accessory: {
                    type: "button",
                    text: {
                      type: "plain_text",
                      text: "View Deployment"
                    },
                    url: "${{ env.STAGING_URL }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: env.SLACK_WEBHOOK_URL != ''

      - name: Update deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const deployments = await github.rest.repos.listDeployments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              environment: 'staging',
              ref: context.sha
            });
            
            if (deployments.data.length > 0) {
              const deployment = deployments.data[0];
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deployment.id,
                state: '${{ steps.status.outputs.status }}',
                environment_url: '${{ env.STAGING_URL }}',
                description: '${{ steps.status.outputs.message }}'
              });
            }

      - name: Clean up old artifacts
        run: |
          echo "ðŸ§¹ Cleaning up old artifacts..."
          # This will be handled by GitHub's retention policy, but we can log it
          echo "Artifacts will be cleaned up automatically after 30 days"