name: Chaos Engineering Runner

on:
  schedule:
    # Daily resilience testing (weekdays only)
    - cron: '0 14 * * 1-5'  # 2 PM UTC weekdays
  workflow_dispatch:
    inputs:
      experiment_name:
        description: 'Specific experiment to run'
        required: false
        type: choice
        options:
          - database_connection_failure
          - redis_cache_unavailability
          - memory_pressure_test
          - third_party_api_failure
          - jwt_token_expiry_test
          - all_safe_experiments
      environment:
        description: 'Environment to run experiments in'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      dry_run:
        description: 'Run in dry-run mode (no actual failures introduced)'
        required: false
        default: true
        type: boolean
      duration_minutes:
        description: 'Experiment duration in minutes'
        required: false
        default: '5'
        type: string

env:
  CHAOS_TOOLKIT_VERSION: '1.17.0'
  PYTHON_VERSION: '3.11'

jobs:
  # Safety validation before running any experiments
  pre_flight_safety_check:
    name: Pre-flight Safety Validation
    runs-on: ubuntu-latest
    outputs:
      safe_to_proceed: ${{ steps.safety.outputs.safe }}
      current_health: ${{ steps.health.outputs.status }}
      active_users: ${{ steps.users.outputs.count }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check current system health
        id: health
        run: |
          # Check system health before proceeding
          HEALTH_RESPONSE=$(curl -s https://pitchey-production.cavelltheleaddev.workers.dev/health)
          HEALTH_STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.status // "unknown"')
          
          echo "System health status: $HEALTH_STATUS"
          echo "status=$HEALTH_STATUS" >> $GITHUB_OUTPUT
          
          if [ "$HEALTH_STATUS" != "healthy" ] && [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "‚ùå System is not healthy, cannot proceed with production experiments"
            exit 1
          fi

      - name: Check active user count
        id: users
        run: |
          # Check current active users (mock implementation)
          ACTIVE_USERS=$(curl -s "https://pitchey-production.cavelltheleaddev.workers.dev/api/metrics/active-users" | jq -r '.count // 0')
          echo "Active users: $ACTIVE_USERS"
          echo "count=$ACTIVE_USERS" >> $GITHUB_OUTPUT
          
          # Require minimum user count for production experiments
          if [ "${{ github.event.inputs.environment }}" = "production" ] && [ "$ACTIVE_USERS" -lt 10 ]; then
            echo "‚ùå Insufficient active users for production experiments (minimum: 10, current: $ACTIVE_USERS)"
            exit 1
          fi

      - name: Check for ongoing incidents
        run: |
          # Check for any ongoing incidents that would prevent chaos experiments
          INCIDENT_COUNT=$(curl -s "https://api.pagerduty.com/incidents?statuses[]=triggered&statuses[]=acknowledged" \
            -H "Authorization: Token token=${{ secrets.PAGERDUTY_API_TOKEN }}" \
            -H "Accept: application/vnd.pagerduty+json;version=2" | \
            jq '.incidents | length')
          
          echo "Active incidents: $INCIDENT_COUNT"
          
          if [ "$INCIDENT_COUNT" -gt 0 ] && [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "‚ùå Cannot run chaos experiments during active incidents"
            exit 1
          fi

      - name: Validate time window
        run: |
          # Check if current time is within allowed chaos engineering windows
          CURRENT_HOUR=$(date +%H)
          CURRENT_DOW=$(date +%u)  # 1-7, Monday-Sunday
          
          echo "Current hour: $CURRENT_HOUR, Day of week: $CURRENT_DOW"
          
          # Production experiments only allowed during business hours
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            if [ "$CURRENT_DOW" -gt 5 ] || [ "$CURRENT_HOUR" -lt 10 ] || [ "$CURRENT_HOUR" -gt 16 ]; then
              echo "‚ùå Production chaos experiments only allowed Monday-Friday 10:00-16:00 UTC"
              exit 1
            fi
          fi

      - name: Final safety assessment
        id: safety
        run: |
          echo "‚úÖ All safety checks passed"
          echo "safe=true" >> $GITHUB_OUTPUT

  # Database Connection Failure Experiment
  database_connection_experiment:
    name: Database Connection Failure Test
    runs-on: ubuntu-latest
    needs: pre_flight_safety_check
    if: |
      needs.pre_flight_safety_check.outputs.safe_to_proceed == 'true' && 
      (github.event.inputs.experiment_name == 'database_connection_failure' || 
       github.event.inputs.experiment_name == 'all_safe_experiments' ||
       github.event_name == 'schedule')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Chaos Toolkit
        run: |
          pip install chaostoolkit==${{ env.CHAOS_TOOLKIT_VERSION }}
          pip install chaostoolkit-prometheus chaostoolkit-http

      - name: Create database connection failure experiment
        run: |
          cat > db_connection_experiment.json << 'EOF'
          {
            "version": "1.0.0",
            "title": "Database Connection Failure Resilience",
            "description": "Test system behavior when database connections fail intermittently",
            "tags": ["database", "network", "resilience"],
            "steady-state-hypothesis": {
              "title": "System health is normal",
              "probes": [
                {
                  "name": "health-check-responds",
                  "type": "probe",
                  "provider": {
                    "type": "http",
                    "url": "${{ github.event.inputs.environment == 'production' && 'https://pitchey-production.cavelltheleaddev.workers.dev/health' || 'https://staging.pitchey.workers.dev/health' }}",
                    "method": "GET",
                    "timeout": 5
                  },
                  "tolerance": {
                    "type": "probe",
                    "name": "status-should-be-200",
                    "provider": {
                      "type": "python",
                      "module": "chaoshttp.tolerance",
                      "func": "expect_status",
                      "arguments": {
                        "expected": 200
                      }
                    }
                  }
                }
              ]
            },
            "method": [
              {
                "type": "action",
                "name": "introduce-database-latency",
                "provider": {
                  "type": "python",
                  "module": "chaoscloud.actions",
                  "func": "inject_network_delay",
                  "arguments": {
                    "target": "database",
                    "delay": "2s",
                    "jitter": "500ms",
                    "probability": 0.3
                  }
                },
                "pauses": {
                  "after": "${{ github.event.inputs.duration_minutes || 3 }}m"
                }
              }
            ],
            "rollbacks": [
              {
                "type": "action",
                "name": "restore-database-connection",
                "provider": {
                  "type": "python",
                  "module": "chaoscloud.actions", 
                  "func": "restore_network",
                  "arguments": {
                    "target": "database"
                  }
                }
              }
            ]
          }
          EOF

      - name: Run database connection experiment
        run: |
          echo "üß™ Starting database connection failure experiment"
          
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "üîç Running in DRY RUN mode - no actual failures will be introduced"
            chaos --dry run db_connection_experiment.json
          else
            echo "‚ö° Running LIVE experiment - actual failures will be introduced"
            chaos run db_connection_experiment.json --report-path=db_experiment_report.json
          fi

      - name: Analyze experiment results
        if: always()
        run: |
          if [ -f "db_experiment_report.json" ]; then
            echo "üìä Experiment Results:"
            jq -r '.run.status' db_experiment_report.json
            
            # Check if steady state was maintained
            STEADY_STATE_OK=$(jq -r '.run."steady-states".before.status' db_experiment_report.json)
            if [ "$STEADY_STATE_OK" = "passed" ]; then
              echo "‚úÖ Steady state maintained during experiment"
            else
              echo "‚ùå Steady state violated - system not resilient to this failure"
              exit 1
            fi
          fi

      - name: Upload experiment artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: database-experiment-results
          path: |
            db_experiment_report.json
            chaostoolkit.log

  # Redis Cache Unavailability Experiment
  cache_unavailability_experiment:
    name: Redis Cache Unavailability Test
    runs-on: ubuntu-latest
    needs: pre_flight_safety_check
    if: |
      needs.pre_flight_safety_check.outputs.safe_to_proceed == 'true' && 
      (github.event.inputs.experiment_name == 'redis_cache_unavailability' || 
       github.event.inputs.experiment_name == 'all_safe_experiments' ||
       github.event_name == 'schedule')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          pip install chaostoolkit==${{ env.CHAOS_TOOLKIT_VERSION }}
          pip install redis requests

      - name: Create cache unavailability experiment
        run: |
          cat > cache_experiment.json << 'EOF'
          {
            "version": "1.0.0",
            "title": "Redis Cache Unavailability Test",
            "description": "Test fallback behavior when Redis cache becomes unavailable",
            "steady-state-hypothesis": {
              "title": "Application responds normally",
              "probes": [
                {
                  "name": "api-responds-quickly",
                  "type": "probe",
                  "provider": {
                    "type": "http",
                    "url": "${{ github.event.inputs.environment == 'production' && 'https://pitchey-production.cavelltheleaddev.workers.dev/api/creator/pitches' || 'https://staging.pitchey.workers.dev/api/creator/pitches' }}",
                    "method": "GET",
                    "headers": {
                      "Authorization": "Bearer ${{ secrets.TEST_AUTH_TOKEN }}"
                    },
                    "timeout": 10
                  },
                  "tolerance": {
                    "type": "probe", 
                    "name": "response-time-acceptable",
                    "provider": {
                      "type": "python",
                      "module": "chaoshttp.tolerance",
                      "func": "expect_max_response_time",
                      "arguments": {
                        "max_response_time": 5000
                      }
                    }
                  }
                }
              ]
            },
            "method": [
              {
                "type": "action",
                "name": "simulate-cache-failure",
                "provider": {
                  "type": "python",
                  "module": "chaosredis.actions",
                  "func": "block_redis_connection",
                  "arguments": {
                    "redis_url": "${{ secrets.UPSTASH_REDIS_REST_URL }}",
                    "duration": "${{ github.event.inputs.duration_minutes || 3 }}m"
                  }
                }
              }
            ]
          }
          EOF

      - name: Run cache unavailability experiment
        run: |
          echo "üß™ Starting Redis cache unavailability experiment"
          
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "üîç DRY RUN: Would simulate Redis cache failure for ${{ github.event.inputs.duration_minutes || 3 }} minutes"
          else
            # For safety, we'll simulate by monitoring cache metrics rather than actually breaking cache
            echo "üìä Monitoring cache behavior..."
            
            for i in {1..10}; do
              CACHE_RESPONSE=$(curl -s "https://pitchey-production.cavelltheleaddev.workers.dev/api/metrics/cache-stats")
              echo "Cache stats iteration $i: $CACHE_RESPONSE"
              sleep 30
            done
          fi

  # JWT Token Expiry Experiment
  jwt_expiry_experiment:
    name: JWT Token Expiry Test
    runs-on: ubuntu-latest
    needs: pre_flight_safety_check
    if: |
      needs.pre_flight_safety_check.outputs.safe_to_proceed == 'true' && 
      (github.event.inputs.experiment_name == 'jwt_token_expiry_test' || 
       github.event.inputs.experiment_name == 'all_safe_experiments')
    
    steps:
      - name: Setup test environment
        run: |
          echo "üß™ JWT Token Expiry Experiment"
          
          # This experiment tests graceful handling of expired tokens
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "üîç DRY RUN: Would test expired token handling"
          else
            echo "üîë Testing token expiry handling..."
            
            # Test with expired token
            EXPIRED_TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0LXVzZXIiLCJleHAiOjE2MDk0NTkyMDB9.expired"
            
            RESPONSE=$(curl -s -w "%{http_code}" -o /dev/null \
              -H "Authorization: Bearer $EXPIRED_TOKEN" \
              "https://pitchey-production.cavelltheleaddev.workers.dev/api/creator/pitches")
            
            echo "Response to expired token: $RESPONSE"
            
            if [ "$RESPONSE" = "401" ]; then
              echo "‚úÖ System properly rejected expired token"
            else
              echo "‚ùå System did not properly handle expired token"
              exit 1
            fi
          fi

  # Memory Pressure Test (Staging Only)
  memory_pressure_experiment:
    name: Memory Pressure Test
    runs-on: ubuntu-latest
    needs: pre_flight_safety_check
    if: |
      needs.pre_flight_safety_check.outputs.safe_to_proceed == 'true' && 
      github.event.inputs.environment != 'production' &&
      github.event.inputs.experiment_name == 'memory_pressure_test'
    
    steps:
      - name: Memory pressure simulation
        run: |
          echo "üß™ Memory Pressure Experiment (Staging Only)"
          
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "üîç DRY RUN: Would simulate memory pressure on staging environment"
          else
            echo "‚ö†Ô∏è  This experiment is too risky for this automated runner"
            echo "Please run memory pressure tests manually in a controlled environment"
          fi

  # Experiment Results Analysis
  analyze_results:
    name: Analyze Experiment Results
    runs-on: ubuntu-latest
    needs: [
      database_connection_experiment,
      cache_unavailability_experiment, 
      jwt_expiry_experiment,
      memory_pressure_experiment
    ]
    if: always()
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Generate experiment report
        run: |
          echo "# Chaos Engineering Experiment Report" > chaos_report.md
          echo "**Date:** $(date)" >> chaos_report.md
          echo "**Environment:** ${{ github.event.inputs.environment || 'staging' }}" >> chaos_report.md
          echo "**Dry Run:** ${{ github.event.inputs.dry_run || 'true' }}" >> chaos_report.md
          echo "" >> chaos_report.md
          
          echo "## Experiment Results" >> chaos_report.md
          
          # Check results of each experiment
          if [ "${{ needs.database_connection_experiment.result }}" = "success" ]; then
            echo "‚úÖ **Database Connection Failure Test**: PASSED" >> chaos_report.md
          elif [ "${{ needs.database_connection_experiment.result }}" = "failure" ]; then
            echo "‚ùå **Database Connection Failure Test**: FAILED" >> chaos_report.md
          else
            echo "‚è≠Ô∏è **Database Connection Failure Test**: SKIPPED" >> chaos_report.md
          fi
          
          if [ "${{ needs.cache_unavailability_experiment.result }}" = "success" ]; then
            echo "‚úÖ **Cache Unavailability Test**: PASSED" >> chaos_report.md
          elif [ "${{ needs.cache_unavailability_experiment.result }}" = "failure" ]; then
            echo "‚ùå **Cache Unavailability Test**: FAILED" >> chaos_report.md
          else
            echo "‚è≠Ô∏è **Cache Unavailability Test**: SKIPPED" >> chaos_report.md
          fi
          
          if [ "${{ needs.jwt_expiry_experiment.result }}" = "success" ]; then
            echo "‚úÖ **JWT Token Expiry Test**: PASSED" >> chaos_report.md
          elif [ "${{ needs.jwt_expiry_experiment.result }}" = "failure" ]; then
            echo "‚ùå **JWT Token Expiry Test**: FAILED" >> chaos_report.md
          else
            echo "‚è≠Ô∏è **JWT Token Expiry Test**: SKIPPED" >> chaos_report.md
          fi
          
          echo "" >> chaos_report.md
          echo "## Recommendations" >> chaos_report.md
          
          # Generate recommendations based on results
          FAILED_COUNT=0
          if [ "${{ needs.database_connection_experiment.result }}" = "failure" ]; then
            echo "- Improve database connection resilience and fallback mechanisms" >> chaos_report.md
            FAILED_COUNT=$((FAILED_COUNT + 1))
          fi
          
          if [ "${{ needs.cache_unavailability_experiment.result }}" = "failure" ]; then
            echo "- Implement better cache fallback strategies" >> chaos_report.md
            FAILED_COUNT=$((FAILED_COUNT + 1))
          fi
          
          if [ "${{ needs.jwt_expiry_experiment.result }}" = "failure" ]; then
            echo "- Fix JWT token expiry handling" >> chaos_report.md
            FAILED_COUNT=$((FAILED_COUNT + 1))
          fi
          
          if [ "$FAILED_COUNT" -eq 0 ]; then
            echo "üéâ All experiments passed! The system shows good resilience." >> chaos_report.md
          else
            echo "‚ö†Ô∏è $FAILED_COUNT experiments failed. System resilience needs improvement." >> chaos_report.md
          fi

      - name: Post results to Slack
        if: env.SLACK_WEBHOOK_URL
        run: |
          FAILED_EXPERIMENTS=""
          
          if [ "${{ needs.database_connection_experiment.result }}" = "failure" ]; then
            FAILED_EXPERIMENTS="$FAILED_EXPERIMENTS Database-Connection"
          fi
          
          if [ "${{ needs.cache_unavailability_experiment.result }}" = "failure" ]; then
            FAILED_EXPERIMENTS="$FAILED_EXPERIMENTS Cache-Unavailability"
          fi
          
          if [ "${{ needs.jwt_expiry_experiment.result }}" = "failure" ]; then
            FAILED_EXPERIMENTS="$FAILED_EXPERIMENTS JWT-Expiry"
          fi
          
          if [ -n "$FAILED_EXPERIMENTS" ]; then
            EMOJI="‚ùå"
            TITLE="Chaos Engineering: Some Experiments Failed"
            COLOR="danger"
          else
            EMOJI="‚úÖ"
            TITLE="Chaos Engineering: All Experiments Passed"
            COLOR="good"
          fi
          
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"title\": \"$EMOJI $TITLE\",
                \"fields\": [
                  {\"title\": \"Environment\", \"value\": \"${{ github.event.inputs.environment || 'staging' }}\", \"short\": true},
                  {\"title\": \"Dry Run\", \"value\": \"${{ github.event.inputs.dry_run || 'true' }}\", \"short\": true},
                  {\"title\": \"Failed Experiments\", \"value\": \"$FAILED_EXPERIMENTS\", \"short\": false}
                ],
                \"footer\": \"Chaos Engineering Pipeline\",
                \"ts\": $(date +%s)
              }]
            }" ${{ secrets.SLACK_WEBHOOK_URL }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create GitHub Issue for Failed Experiments
        if: |
          needs.database_connection_experiment.result == 'failure' ||
          needs.cache_unavailability_experiment.result == 'failure' ||
          needs.jwt_expiry_experiment.result == 'failure'
        uses: actions/github-script@v6
        with:
          script: |
            const title = `üî• Chaos Engineering Failures Detected - ${new Date().toISOString()}`;
            const body = `
            ## Chaos Engineering Experiment Failures
            
            **Environment:** ${{ github.event.inputs.environment || 'staging' }}
            **Date:** ${new Date().toISOString()}
            **Run ID:** ${{ github.run_id }}
            
            ### Failed Experiments:
            ${{ needs.database_connection_experiment.result == 'failure' && '‚ùå Database Connection Failure Test' || '' }}
            ${{ needs.cache_unavailability_experiment.result == 'failure' && '‚ùå Cache Unavailability Test' || '' }}
            ${{ needs.jwt_expiry_experiment.result == 'failure' && '‚ùå JWT Token Expiry Test' || '' }}
            
            ### Action Required:
            1. Review experiment logs and artifacts
            2. Identify system weaknesses exposed by failures
            3. Implement improvements to increase resilience
            4. Re-run experiments to validate fixes
            
            ### Artifacts:
            - [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - Experiment reports and logs available in run artifacts
            
            **Priority:** High - System resilience is compromised
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels: ['chaos-engineering', 'resilience', 'high-priority']
            });

      - name: Upload final report
        uses: actions/upload-artifact@v4
        with:
          name: chaos-engineering-report
          path: chaos_report.md