name: üöÄ Production Deployment Pipeline

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'frontend/**'
      - 'wrangler.toml'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      deploy_target:
        description: 'Deployment target'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - frontend
          - worker
          - backend
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean
      dry_run:
        description: 'Dry run (no actual deployment)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  DENO_VERSION: '1.x'
  DEPLOY_ENVIRONMENT: 'production'

jobs:
  # Pre-deployment validation
  validate:
    name: üîç Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      commit_hash: ${{ steps.vars.outputs.commit_hash }}
      release_name: ${{ steps.vars.outputs.release_name }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: ü¶ï Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: ${{ env.DENO_VERSION }}
      
      - name: üìä Set variables
        id: vars
        run: |
          echo "commit_hash=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "release_name=pitchey@$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
      
      - name: üîç Check deployment conditions
        id: check
        run: |
          # Check if this is a main branch push or manual workflow
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi
      
      - name: üìã Validate environment variables
        run: |
          required_vars=(
            "CLOUDFLARE_API_TOKEN"
            "CLOUDFLARE_ACCOUNT_ID" 
            "DATABASE_URL"
            "JWT_SECRET"
          )
          
          missing_vars=()
          for var in "${required_vars[@]}"; do
            if [ -z "${!var:-}" ]; then
              missing_vars+=("$var")
            fi
          done
          
          if [ ${#missing_vars[@]} -ne 0 ]; then
            echo "‚ùå Missing required environment variables: ${missing_vars[*]}"
            exit 1
          fi
          
          echo "‚úÖ All required environment variables are set"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}

  # Frontend testing and building
  frontend-test:
    name: üß™ Frontend Tests & Build
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.should_deploy == 'true' && !inputs.skip_tests
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: üì¶ Install dependencies
        working-directory: frontend
        run: npm ci
      
      - name: üîç Lint code
        working-directory: frontend
        run: npm run lint
      
      - name: üß™ Type check
        working-directory: frontend
        run: npm run type-check
      
      - name: üß™ Run unit tests
        working-directory: frontend
        run: npm run test:ci
        env:
          CI: true
      
      - name: üèóÔ∏è Build for production
        working-directory: frontend
        run: npm run build:prod
        env:
          NODE_ENV: production
          VITE_API_URL: https://pitchey-production.cavelltheleaddev.workers.dev
          VITE_WS_URL: wss://pitchey-production.cavelltheleaddev.workers.dev/ws
          VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
          SENTRY_RELEASE: ${{ needs.validate.outputs.release_name }}
      
      - name: üì§ Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist
          retention-days: 7

  # Backend testing
  backend-test:
    name: üß™ Backend Tests
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.should_deploy == 'true' && !inputs.skip_tests
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: ü¶ï Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: ${{ env.DENO_VERSION }}
      
      - name: üß™ Run tests
        run: |
          # Run any Deno tests if they exist
          if [ -f "deno.json" ] || [ -f "deno.jsonc" ]; then
            deno test --allow-all
          fi
      
      - name: üîç Check code formatting
        run: deno fmt --check || echo "‚ö†Ô∏è Code formatting check skipped"
      
      - name: üîç Lint Deno code
        run: deno lint || echo "‚ö†Ô∏è Deno linting skipped"
      
      - name: ‚úÖ Validate worker syntax
        run: |
          deno check src/worker-platform-complete.ts

  # Database migrations
  database-migrate:
    name: üóÑÔ∏è Database Migration
    runs-on: ubuntu-latest
    needs: [validate, frontend-test, backend-test]
    if: always() && needs.validate.outputs.should_deploy == 'true' && (needs.frontend-test.result == 'success' || needs.frontend-test.result == 'skipped') && (needs.backend-test.result == 'success' || needs.backend-test.result == 'skipped')
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: üîß Setup Drizzle
        run: npm install -g drizzle-orm @neondatabase/serverless
      
      - name: üìä Check database connectivity
        run: |
          node -e "
          const { neon } = require('@neondatabase/serverless');
          const sql = neon(process.env.DATABASE_URL);
          sql\`SELECT NOW() as current_time\`.then(
            result => {
              console.log('‚úÖ Database connected:', result[0].current_time);
              process.exit(0);
            },
            error => {
              console.error('‚ùå Database connection failed:', error.message);
              process.exit(1);
            }
          );
          "
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
      
      - name: üóÑÔ∏è Run migrations
        run: |
          if [ -d "drizzle" ] && [ "$(ls -A drizzle)" ]; then
            echo "Running database migrations..."
            # Add migration command here when ready
            echo "‚úÖ Migrations completed (or skipped if none pending)"
          else
            echo "‚ö†Ô∏è No migrations found"
          fi
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

  # Deploy Cloudflare Worker
  deploy-worker:
    name: ‚öôÔ∏è Deploy Worker
    runs-on: ubuntu-latest
    needs: [validate, database-migrate]
    if: always() && needs.validate.outputs.should_deploy == 'true' && needs.database-migrate.result == 'success' && (github.event.inputs.deploy_target == 'worker' || github.event.inputs.deploy_target == 'all' || github.event.inputs.deploy_target == '')
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: üì¶ Install Wrangler
        run: npm install -g wrangler
      
      - name: üîë Authenticate Wrangler
        run: echo "${{ secrets.CLOUDFLARE_API_TOKEN }}" | wrangler auth login --token
      
      - name: ‚úÖ Validate worker configuration
        run: wrangler validate
      
      - name: üöÄ Deploy worker (dry run)
        if: inputs.dry_run
        run: |
          echo "üß™ DRY RUN: Would deploy Cloudflare Worker"
          wrangler deploy --dry-run --minify
      
      - name: üöÄ Deploy worker
        if: !inputs.dry_run
        run: wrangler deploy --minify
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      
      - name: üîê Update worker secrets
        if: !inputs.dry_run
        run: |
          echo "${{ secrets.JWT_SECRET }}" | wrangler secret put JWT_SECRET
          echo "${{ secrets.DATABASE_URL }}" | wrangler secret put DATABASE_URL
          
          # Optional secrets
          if [ -n "${{ secrets.EMAIL_API_KEY }}" ]; then
            echo "${{ secrets.EMAIL_API_KEY }}" | wrangler secret put EMAIL_API_KEY
          fi
          
          if [ -n "${{ secrets.UPSTASH_REDIS_REST_TOKEN }}" ]; then
            echo "${{ secrets.UPSTASH_REDIS_REST_TOKEN }}" | wrangler secret put UPSTASH_REDIS_REST_TOKEN
          fi
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      
      - name: üîç Verify worker deployment
        if: !inputs.dry_run
        run: |
          echo "Waiting for worker to be available..."
          max_attempts=30
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            if curl -sf "https://pitchey-production.cavelltheleaddev.workers.dev/api/health" > /dev/null; then
              echo "‚úÖ Worker is responding"
              break
            fi
            
            attempt=$((attempt + 1))
            echo "‚è≥ Attempt $attempt/$max_attempts - Worker not ready yet..."
            sleep 10
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "‚ùå Worker deployment verification failed"
            exit 1
          fi

  # Deploy Frontend to Cloudflare Pages
  deploy-frontend:
    name: üåê Deploy Frontend
    runs-on: ubuntu-latest
    needs: [validate, frontend-test, deploy-worker]
    if: always() && needs.validate.outputs.should_deploy == 'true' && (needs.frontend-test.result == 'success' || needs.frontend-test.result == 'skipped') && needs.deploy-worker.result == 'success' && (github.event.inputs.deploy_target == 'frontend' || github.event.inputs.deploy_target == 'all' || github.event.inputs.deploy_target == '')
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: üì§ Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist
      
      - name: üì¶ Install Wrangler
        run: npm install -g wrangler
      
      - name: üîë Authenticate Wrangler
        run: echo "${{ secrets.CLOUDFLARE_API_TOKEN }}" | wrangler auth login --token
      
      - name: üöÄ Deploy to Pages (dry run)
        if: inputs.dry_run
        run: |
          echo "üß™ DRY RUN: Would deploy to Cloudflare Pages"
          cd frontend
          echo "Build size: $(du -sh dist | cut -f1)"
          echo "Files: $(find dist -type f | wc -l)"
      
      - name: üöÄ Deploy to Cloudflare Pages
        if: !inputs.dry_run
        run: |
          cd frontend
          wrangler pages deploy dist \
            --project-name=pitchey \
            --branch=main \
            --compatibility-date=2024-11-01
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      
      - name: üîç Verify frontend deployment
        if: !inputs.dry_run
        run: |
          echo "Waiting for frontend to be available..."
          max_attempts=30
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            if curl -sf "https://pitchey.pages.dev" > /dev/null; then
              echo "‚úÖ Frontend is responding"
              break
            fi
            
            attempt=$((attempt + 1))
            echo "‚è≥ Attempt $attempt/$max_attempts - Frontend not ready yet..."
            sleep 10
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "‚ùå Frontend deployment verification failed"
            exit 1
          fi

  # Post-deployment validation
  post-deployment:
    name: ‚úÖ Post-deployment Validation
    runs-on: ubuntu-latest
    needs: [validate, deploy-worker, deploy-frontend]
    if: always() && needs.validate.outputs.should_deploy == 'true' && !inputs.dry_run
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: üß™ Run smoke tests
        run: |
          echo "Running post-deployment smoke tests..."
          
          # Test critical endpoints
          endpoints=(
            "https://pitchey.pages.dev"
            "https://pitchey-production.cavelltheleaddev.workers.dev/api/health"
            "https://pitchey-production.cavelltheleaddev.workers.dev/api/pitches/trending"
          )
          
          for endpoint in "${endpoints[@]}"; do
            echo "Testing: $endpoint"
            if curl -sf "$endpoint" -w "Status: %{http_code}, Time: %{time_total}s\n" -o /dev/null; then
              echo "‚úÖ $endpoint - OK"
            else
              echo "‚ùå $endpoint - FAILED"
              exit 1
            fi
          done
      
      - name: üîç Validate API responses
        run: |
          echo "Validating API responses..."
          
          # Test trending pitches endpoint
          response=$(curl -sf "https://pitchey-production.cavelltheleaddev.workers.dev/api/pitches/trending")
          if echo "$response" | jq empty 2>/dev/null; then
            echo "‚úÖ API returns valid JSON"
          else
            echo "‚ùå API response is not valid JSON"
            exit 1
          fi
      
      - name: üìä Report deployment metrics
        run: |
          echo "üìä Deployment Metrics:"
          echo "- Commit: ${{ needs.validate.outputs.commit_hash }}"
          echo "- Release: ${{ needs.validate.outputs.release_name }}"
          echo "- Environment: ${{ env.DEPLOY_ENVIRONMENT }}"
          echo "- Time: $(date -u)"
          echo "- Frontend Status: ${{ needs.deploy-frontend.result }}"
          echo "- Worker Status: ${{ needs.deploy-worker.result }}"

  # Setup monitoring (optional)
  setup-monitoring:
    name: üìä Setup Monitoring
    runs-on: ubuntu-latest
    needs: [post-deployment]
    if: needs.post-deployment.result == 'success' && !inputs.dry_run
    continue-on-error: true
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîß Setup monitoring (if configured)
        run: |
          if [ -f "scripts/monitoring-setup.sh" ]; then
            echo "Setting up monitoring..."
            # This would require appropriate secrets and configuration
            echo "‚ÑπÔ∏è Monitoring setup requires manual configuration"
          else
            echo "‚ö†Ô∏è No monitoring setup script found"
          fi
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Notification
  notify:
    name: üì¢ Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate, deploy-worker, deploy-frontend, post-deployment]
    if: always() && needs.validate.outputs.should_deploy == 'true'
    
    steps:
      - name: üì§ Send Slack notification (success)
        if: needs.post-deployment.result == 'success' && !inputs.dry_run
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          text: |
            üöÄ *Pitchey Platform Deployed Successfully!*
            
            *Commit:* `${{ needs.validate.outputs.commit_hash }}`
            *Environment:* Production
            
            *Services:*
            ‚Ä¢ Frontend: https://pitchey.pages.dev
            ‚Ä¢ API: https://pitchey-production.cavelltheleaddev.workers.dev
            
            *Status:* ‚úÖ All services healthy
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true
      
      - name: üì§ Send Slack notification (failure)
        if: failure() && !inputs.dry_run
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#deployments'
          text: |
            üö® *Pitchey Platform Deployment Failed!*
            
            *Commit:* `${{ needs.validate.outputs.commit_hash }}`
            *Environment:* Production
            
            Please check the GitHub Actions logs for details.
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true